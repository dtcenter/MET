////////////////////////////////////////////////////////////////////////////////
//
// Configuration file overview.
//
////////////////////////////////////////////////////////////////////////////////

The configuration files that control many of the MET tools contain formatted
ASCII text.  This format has been updated for METv4.0 and continues to be used
in subsequent releases.

Settings common to multiple tools are described in the top part of this README
file and settings specific to individual tools are described beneath the common
settings.  Please refer to the MET User's Guide in the "doc" directory for more
details about the settings if necessary.

A configuration file entry is an entry name, followed by an equal sign (=),
followed by an entry value, and is terminated by a semicolon (;).  The
configuration file itself is one large dictionary consisting of entries, some of
which are dictionaries themselves.

The configuration file language supports the following data types:
   - Dictionary:
      - Grouping of one or more entries enclosed by curly braces {}.
   - Array:
      - List of one or more entries enclosed by square braces [].
      - Array elements are separated by commas.
   - String:
      - A character string enclosed by double quotation marks "".
   - Integer:
      - A numeric integer value.
   - Float:
      - A numeric float value.
   - Boolean:
      - A boolean value (TRUE or FALSE).
   - Threshold:
      - A threshold type (<, <=, ==, !-, >=, or >) followed by a numeric value.
      - The threshold type may also be specified using two letter abbreviations
        (lt, le, eq, ne, ge, gt).
      - Multiple thresholds may be combined by specifying the logic type of AND
        (&&) or OR (||). For example, ">=5&&<=10" defines the numbers between 5
        and 10 and "==1||==2" defines numbers exactly equal to 1 or 2.
   - Piecewise-Linear Function (currently used only by MODE):
      - A list of (x, y) points enclosed in parenthesis ().
      - The (x, y) points are *NOT* separated by commas.

The context of a configuration entry matters.  If an entry cannot be found in
the expected dictionary, the MET tools recursively search for that entry in the
parent dictionaries, all the way up to the top-level configuration file
dictionary.  If you'd like to apply the same setting across all cases, you can
simply specify it once at the top-level.  Alternatively, you can specify a
setting at the appropriate dictionary level to have finer control over the
behavior.

In order to make the configuration files more readable, several descriptive
integer types have been defined in the ConfigConstants file.  These integer
names may be used on the right-hand side for many configuration file entries.

Each of the configurable MET tools expects a certain set of configuration
entries.  Examples of the MET configuration files can be found in data/config
and scripts/config.

When you pass a configuration file to a MET tool, the tool actually parses up
to four different configuration files in the following order:
   (1) Reads share/met/config/ConfigConstants to define constants.
   (2) If the tool produces PostScript output, it reads
       share/met/config/ConfigMapData to define the map data to be plotted.
   (3) Reads the default configuration file for the tool from share/met/config.
   (4) Reads the user-specified configuration file from the command line.

Many of the entries from step (3) are overwritten by the user-specified entries
from step (4).  Therefore, the configuration file you pass in on the command
line really only needs to contain entries that differ from the defaults.

Any of the configuration entries may be overwritten by the user-specified
configuration file.  For example, the map data to be plotted may be included in
the user-specified configuration file and override the default settings defined
in the share/met/config/ConfigMapData file.

The configuration file language supports the use of environment variables. They
are specified as ${ENV_VAR}, where ENV_VAR is the name of the environment
variable.  When scripting up many calls to the MET tools, you may find it
convenient to use them.  For example, when applying the same configuration to
the output from multiple models, consider defining the model name as an
environment variable which the controlling script sets prior to verifying the
output of each model.  Setting MODEL to that environment variable enables you
to use one configuration file rather than maintianing many very similar ones.

The MET_BASE variable is defined in the code at compilation time as the path
to the MET shared data.  These are things like the default configuration files,
common polygons and color scales.  MET_BASE may be used in the MET configuration
files when specifying paths and the appropriate path will be substituted in.
If MET_BASE is defined as an environment variable, its value will be used
instead of the one defined at compilation time.

The MET_GRIB_TABLES environment variable can be set to specify the location of
custom GRIB tables.  It can either be set to a specific file name or to a
directory containing custom GRIB tables files.  These file names must begin with
a "grib1" or "grib2" prefix and end with a ".txt" suffix.  Their format must
match the format used by the default GRIB table files located in
share/met/table_files.  The custom GRIB tables are read prior to the default
tables and their settings take precedence.

An error in the syntax of a configuration file will result in an error from the
MET tool stating the location of the parsing error.

////////////////////////////////////////////////////////////////////////////////
//
// Configuration settings used by the MET tools.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// Settings common to multiple tools
//
////////////////////////////////////////////////////////////////////////////////

//
// The "exit_on_warning" entry in ConfigConstants may be set to true or false.
// If set to true and a MET tool encounters a warning, it will immediately exit
// with bad status after writing the warning message.
//
exit_on_warning = FALSE;

//
// The "nc_compression" entry in ConfigConstants defines the compression level
// for the NetCDF variables. Setting this option in the config file of one of
// the tools overrides the default value set in ConfigConstants. The
// environment variable MET_NC_COMPRESS overrides the compression level
// from configuration file. The command line argument "-compress n" for some
// tools overrides it.
// The range is 0 to 9.
//   - 0 is to disable the compression.
//   - 1 to 9: Lower number is faster, higher number is better.
nc_compression = 0;

//
// The "output_precision" entry in ConfigConstants defines the precision
// (number of significant decimal places) to be written to the ASCII output
// files.  Setting this option in the config file of one of the tools will
// override the default value set in ConfigConstants.
//
output_precision = 5;

// The "tmp_dir" entry in ConfigConstants defines the directory for the
// temporary files. The directory must exist and be writable. The environment
// variable MET_TMP_DIR overrides the default value at the configuration file.
// Some tools override the temporary directory by the command line argument
// "-tmp_dir <diretory_name>".
tmp_dir = "/tmp";

//
// The "model" entry specifies a name for the model being verified.  This name
// is written to the MODEL column of the ASCII output generated.  If you're
// verifying multiple models, you should choose descriptive model names (no
// whitespace) to distinguish between their output.
// e.g. model = "GFS";
//
model = "WRF";

//
// The "desc" entry specifies a user-specified description for each verification
// task.  This string is written to the DESC column of the ASCII output
// generated.  It may be set separately in each "obs.field" verification task
// entry or simply once at the top level of the configuration file.  If you're
// verifying the same field multiple times with different quality control
// flags, you should choose description strings (no whitespace) to distinguish
// between their output.
// e.g. desc = "QC_9";
//
desc = "NA";

//
// The "obtype" entry specifies a name to describe the type of verifying gridded
// observation used.  This name is written to the OBTYPE column in the ASCII
// output generated.  If you're using multiple types of verifying observations,
// you should choose a descriptive name (no whitespace) to distinguish between
// their output.  When verifying against point observations the point
// observation message type value is written to the OBTYPE column.  Otherwise,
// the configuration file obtype value is written.
//
obtype = "ANALYS";

//
// The "regrid" entry is a dictionary containing information about how to handle
// input gridded data files.  The "regrid" entry specifies regridding logic
// using the following entries:
//
//   - The "to_grid" entry may be set to NONE, FCST, OBS, a named grid, the path
//     to a gridded data file defining the grid, or an explicit grid specification
//     string.
//      - to_grid = NONE;   To disable regridding.
//      - to_grid = FCST;   To regrid observations to the forecast grid.
//      - to_grid = OBS;    To regrid forecasts to the observation grid.
//      - to_grid = "G218"; To regrid both to a named grid.
//      - to_grid = "path"; To regrid both to a grid defined by a file.
//      - to_grid = "spec"; To define a grid specified as follows:
//         - lambert Nx Ny lat_ll lon_ll lon_orient D_km R_km standard_parallel_1
//           [standard_parallel_2]
//         - stereo Nx Ny lat_ll lon_ll lon_orient D_km R_km lat_scale N|S
//         - latlon Nx Ny lat_ll lon_ll delta_lat delta_lon
//         - mercator Nx Ny lat_ll lon_ll lat_ur lon_ur
//
//    - The "vld_thresh" entry specifies a proportion between 0 and 1 to define
//      the required ratio of valid data points.  When regridding, compute
//      a ratio of the number of valid data points to the total number of
//      points in the neighborhood.  If that ratio is less than this threshold,
//      write bad data for the current point.
//
//   - The "method" entry defines the regridding method to be used.
//      - Valid regridding methods:
//         - MIN         for the minimum value
//         - MAX         for the maximum value
//         - MEDIAN      for the median value
//         - UW_MEAN     for the unweighted average value
//         - DW_MEAN     for the distance-weighted average value (weight = distance^-2)
//         - LS_FIT      for a least-squares fit
//         - BILIN       for bilinear interpolation (width = 2)
//         - NEAREST     for the nearest grid point (width = 1)
//         - BUDGET      for the mass-conserving budget interpolation
//         - FORCE       to compare gridded data directly with no interpolation
//                       as long as the grid x and y dimensions match.
//         - UPPER_LEFT  for the upper left grid point (width = 1)
//         - UPPER_RIGHT for the upper right grid point (width = 1)
//         - LOWER_RIGHT for the lower right grid point (width = 1)
//         - LOWER_LEFT  for the lower left grid point (width = 1)
//
//         The BEST interpolation option is not valid for regridding.
//
//   - The "width" entry specifies a regridding width, when applicable.
//      - width = 4;        To regrid using a 4x4 box.
//
regrid = {
   to_grid    = NONE;
   method     = NEAREST;
   width      = 1;
   vld_thresh = 0.5;
}

//
// The "fcst" entry is a dictionary containing information about the field(s)
// to be verified.  This dictionary may include the following entries:
//
//   - The "field" entry is an array of dictionaries, each specifying a
//     verification task.  Each of these dictionaries may include:
//
//      - The "name" entry specifies a name for the field.
//
//      - The "level" entry specifies level information for the field.
//
//      - Setting "name" and "level" is file-format specific.  See below.
//
//      - The "prob" entry in the forecast dictionary defines probability
//        information.  It may either be set as a boolean (i.e. TRUE or FALSE)
//        or as a dictionary defining probabilistic field information.
//
//        When set as a boolean to TRUE, it indicates that the "fcst.field" data
//        should be treated as probabilities.  For example, when verifying the
//        probabilistic NetCDF output of Ensemble-Stat, one could configure the
//        Grid-Stat or Point-Stat tools as follows:
//
//           fcst = {
//              field = [ { name  = "APCP_24_A24_ENS_FREQ_gt0.0";
//                          level = "(*,*)";
//                          prob  = TRUE; } ];
//           }
//
//        Setting "prob = TRUE" indicates that the "APCP_24_A24_ENS_FREQ_gt0.0"
//        data should be processed as probabilities.
//
//        When set as a dictionary, it defines the probabilistic field to be
//        used.  For example, when verifying GRIB files containing probabilistic
//        data,  one could configure the Grid-Stat or Point-Stat tools as
//        follows:
//
//           fcst = {
//              field = [ { name = "PROB"; level = "A24";
//                          prob = { name = "APCP"; thresh_lo = 2.54; } },
//                        { name = "PROB"; level = "P850";
//                          prob = { name = "TMP"; thresh_hi = 273; } } ];
//           }
//
//        The example above selects two probabilistic fields.  In both, "name"
//        is set to "PROB", the GRIB abbreviation for probabilities. The "level"
//        entry defines the level information (i.e. "A24" for a 24-hour
//        accumulation and "P850" for 850mb).  The "prob" dictionary defines the
//        event for which the probability is defined.  The "thresh_lo"
//        (i.e. APCP > 2.54) and/or "thresh_hi" (i.e. TMP < 273) entries are
//         used to define the event threshold(s).
//
//        Probability fields should contain values in the range
//        [0, 1] or [0, 100]. However, when MET encounters a probability field
//        with a range [0, 100], it will automatically rescale it to be [0, 1]
//        before applying the probabilistic verification methods.
//
//      - Set "prob_as_scalar = TRUE" to override the processing of probability
//        data.  When the "prob" entry is set as a dictionary to define the field
//        of interest, setting "prob_as_scalar = TRUE" indicates that this data
//        should be processed as regular scalars rather than probabilities.
//        For example, this option can be used to compute traditional 2x2
//        contingency tables and neighborhood verification statistics for
//        probability data.  It can also be used to compare two probability
//        fields directly.  When this flag is set, probability values are
//        automatically rescaled from the range [0, 100] to [0, 1].
//
//      - The "cat_thresh" entry is an array of thresholds to be used when
//        computing categorical statistics.
//
//      - The "cnt_thresh" entry is an array of thresholds for filtering
//        data prior to computing continuous statistics and partial sums.
//
//      - The "cnt_logic" entry may be set to UNION, INTERSECTION, or SYMDIFF
//        and controls the logic for how the forecast and observed cnt_thresh
//        settings are combined when filtering matched pairs of forecast and
//        observed values.
//
//   - The "file_type" entry specifies the input file type rather than letting
//     the code determine it itself.  For valid file_type values, see "File types"
//     in the data/config/ConfigConstants file.
//
//   - The "wind_thresh" entry is an array of thresholds used to filter wind
//     speed values when computing VL1L2 vector partial sums.  Only those U/V
//     pairs that meet this wind speed criteria will be included in the sums.
//     Setting this threshold to NA will result in all U/V pairs being used.
//
//   - The "wind_logic" entry may be set to UNION, INTERSECTION, or SYMDIFF
//     and controls the logic for how the forecast and observed wind_thresh
//     settings are combined when filtering matched pairs of forecast and
//     observed wind speeds.
//
//   - The "init_time" entry specifies the initialization time in YYYYMMDD[_HH[MMSS]]
//     format.  This entry can be included in the "fcst" entry as shown below or
//     included in the "field" entry if the user would like to use different
//     initialization times for different fields.
//
//   - The "valid_time" entry specifies the valid time in YYYYMMDD[_HH[MMSS]]
//     format.  This entry can be included in the "fcst" entry as shown below or
//     included in the "field" entry if the user would like to use different
//     valid times for different fields.
//
//   - The "lead_time" entry specifies the lead time in HH[MMSS]
//     format.  This entry can be included in the "fcst" entry as shown below or
//     included in the "field" entry if the user would like to use different
//     lead times for different fields.
//
// It is only necessary to use the "init_time", "valid_time", and/or "lead_time"
// settings when verifying a file containing data for multiple output times.
// For example, to verify a GRIB file containing data for many lead times, you
// could use "lead_time" to specify the record to be verified.
//
// File-format specific settings for the "field" entry:
//
//    - GRIB1 and GRIB2:
//       - For custom GRIB tables, see note about MET_GRIB_TABLES.
//       - The "name" entry specifies a GRIB code number or abbreviation.
//         - GRIB1 Product Definition Section:
//           http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html
//         - GRIB2 Product Definition Section:
//           http://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc.shtml
//       - The "level" entry specifies a level type and value:
//          - ANNN for accumulation interval NNN
//          - ZNNN for vertical level NNN
//          - ZNNN-NNN for a range of vertical levels
//          - PNNN for pressure level NNN in hPa
//          - PNNN-NNN for a range of pressure levels in hPa
//          - LNNN for a generic level type
//          - RNNN for a specific GRIB record number
//       - The "GRIB_lvl_typ" entry specifies the level type.
//       - The "GRIB_lvl_val1" and "GRIB_lvl_val2" entries specify the first
//         and second level values.
//       - The "GRIB_ens" entry is a string which specifies NCEP's usage of the
//         extended PDS for ensembles.  Set to "hi_res_ctl", "low_res_ctl", "+n",
//         or "-n", for the n-th ensemble member.
//       - The "GRIB1_ptv" entry specifies the GRIB1 parameter table version number.
//       - The "GRIB1_code" entry specifies the GRIB1 code (wgrib kpds5 value).
//       - The "GRIB1_center" entry specifies the originating center.
//       - The "GRIB1_subcenter" entry specifies the originating subcenter.
//       - The "GRIB2_disc" entry specifies the GRIB2 discipline code.
//       - The "GRIB2_parm_cat" entry specifies the parameter category code.
//       - The "GRIB2_parm" entry specifies the parameter code.
//       - The "GRIB2_pdt" entry specifies the product definition template (Table 4.0).
//       - The "GRIB2_process" entry specifies the generating process (Table 4.3).
//       - The "GRIB2_cntr" entry specifies the originating center.
//       - The "GRIB2_ens_type" entry specifies the ensemble type (Table 4.6).
//       - The "GRIB2_der_type" entry specifies the derived product type (Table 4.7).
//
//    - NetCDF (from MET tools, CF-compliant, p_interp, and wrf_interp):
//       - The "name" entry specifies the NetCDF variable name.
//       - The "level" entry specifies the dimensions to be used:
//          - (i,...,j,*,*) for a single field, where i,...,j specifies fixed
//            dimension values and *,* specifies the two dimensions for the
//            gridded field.
//       e.g.
//           field = [
//             {
//               name       = "QVAPOR";
//               level      = "(0,5,*,*)";
//             },
//             {
//               name       = "TMP_P850_ENS_MEAN";
//               level      = [ "(*,*)" ];
//             }
//
//           ];
//
//
fcst = {
   cnt_thresh   = [ NA ];
   cnt_logic    = UNION;
   wind_thresh  = [ NA ];
   wind_logic   = UNION;
   message_type = [ "ADPSFC" ];
   init_time    = "20120619_12";
   valid_time   = "20120620_00";
   lead_time    = "12";

   field = [
      {
        name       = "APCP";
        level      = [ "A03" ];
        cat_thresh = [ >0.0, >=5.0 ];
      }
   ];
}

//
// The "obs" entry specifies the same type of information as "fcst", but for
// the observation data.  It will often be set to the same things as "fcst",
// as shown in the example below.  However, when comparing forecast and
// observation files of different format types, this entry will need to be set
// in a non-trivial way.  The length of the "obs.field" array must match the
// length of the "fcst.field" array.
//     e.g.
//         obs = fcst;
//
//     or
//
//         fcst = {
//           cnt_thresh  = [ NA ];
//           cnt_logic   = UNION;
//           wind_thresh = [ NA ];
//           wind_logic  = UNION;
//
//           field = [
//              {
//                 name       = "PWAT";
//                 level      = [ "L0" ];
//                 cat_thresh = [ >2.5 ];
//              }
//            ];
//         }
//
//
//         obs = {
//           cnt_thresh  = [ NA ];
//           cnt_logic   = UNION;
//           wind_thresh = [ NA ];
//           wind_logic  = UNION;
//
//           field = [
//              {
//                 name       = "IWV";
//                 level      = [ "L0" ];
//                 cat_thresh = [ >25.0 ];
//              }
//            ];
//         }
//
//
//   - The "message_type" entry is an array of point observation message types
//     to be used.  This only applies to the tools that verify against point
//     observations.  This may be specified once at the top-level "obs"
//     dictionary or separately for each "field" array element.  In the example
//     shown above, this is specified in the "fcst" dictionary and copied to "obs".
//   - The "message_type" would be placed in the "field" array element if more
//     than one "message_type" entry is desired within the config file.
//     e.g.
//     fcst = {
//       cnt_thresh  = [ NA ];
//       cnt_logic   = UNION;
//       wind_thresh = [ NA ];
//       wind_logic  = UNION;
//
//       field = [
//          {
//            message_type = [ "ADPUPA" ];
//            sid_exc      = [];
//            name       = "TMP";
//            level      = [ "P250", "P500", "P700", "P850", "P1000" ];
//            cat_thresh = [ <=273.0 ];
//          },
//          {
//            message_type = [ "ADPSFC" ];
//            sid_exc      = [ "KDEN", "KDET" ];
//            name       = "TMP";
//            level      = [ "Z2" ];
//            cat_thresh = [ <=273.0 ];
//          }
//       ];
//     }
//
//    - The "sid_exc" entry is an array of station ID groups indicating which
//      station ID's should be excluded from the verification tasks.  Each element
//      is either the name of a single station ID or the full path to a station ID
//      group file name.  A station ID group file consists of a name for the group
//      followed by a list of station ID's.  All of the station ID's indicated will
//      be placed into one long list of station ID's to be excluded.
//    - As with "message_type" above, the "sid_exc" setting can be placed in the
//      in the "field" array element to control which station ID's are excluded
//      for each verification task.
//
obs = fcst;

//
// The "climo_mean" dictionary specifies climatology data to read by the
// Grid-Stat, Point-Stat, and Ensemble-Stat tools.  It consists of several
// entires defining the climatology file names and fields to be used.
//
//   - The "file_names" entry specifies one or more file names containing
//     the gridded climatology data to be used.
//
//   - The "field" entry is an array of dictionaries, specified the same
//     way as those in the "fcst" and "obs" dictionaries.  If the array has
//     length zero, not climatology data will be read and all climatology
//     statistics will be written as missing data.  Otherwise, the array
//     length must match the length of "field" in the "fcst" and "obs"
//     dictionaries.
//
//   - The "regrid" dictionary defines how the climatology data should be
//     regridded to the verification domain.
//
//   - The "time_interp_method" entry specifies how the climatology data should
//     be interpolated in time to the forecast valid time:
//      - NEAREST for data closest in time
//      - UW_MEAN for average of data before and after
//      - DW_MEAN for linear interpolation in time of data before and after
//
//   - The "match_day" entry may be set to TRUE or FALSE.  When searching
//     climatology data, only consider times where the month matches the
//     forecast valid month.  Set match_day to TRUE or FALSE to define whether
//     the climatology day must also match.
//      - match_day = FALSE for monthly climatology
//      - match_day = TRUE  for daily climatology
//
//   - The "time_step" entry specifies the spacing of climatology data in
//     seconds.  Set to 60*60*6 = 21600 for 6-hourly data or 60*60 = 3600
//     for hourly data.
//
climo_mean = {

   file_name = [];
   field     = [];

   regrid = {
      method     = NEAREST;
      width      = 1;
      vld_thresh = 0.5;
   }

   time_interp_method = DW_MEAN;
   match_day          = FALSE;
   time_step          = 21600;
}

//
// The "mask_missing_flag" entry specifies how missing data should be handled
// in the Wavelet-Stat and MODE tools:
//    - "NONE" to perform no masking of missing data
//    - "FCST" to mask the forecast field with missing observation data
//    - "OBS" to mask the observation field with missing forecast data
//    - "BOTH" to mask both fields with missing data from the other
//
mask_missing_flag = BOTH;

//
// The "obs_window" entry is a dictionary specifying a beginning ("beg"
// entry) and ending ("end" entry) time offset values in seconds.  It defines
// the time window over which observations are retained for scoring. These time
// offsets are defined relative to a reference time t, as [t+beg, t+end].
// In PB2NC, the reference time is the PrepBufr files center time.  In
// Point-Stat and Ensemble-Stat, the reference time is the forecast valid time.
//
obs_window = {
   beg = -5400;
   end =  5400;
}

//
// The "mask" entry is a dictionary that specifies the verification masking
// regions to be used when computing statistics.  Each mask defines a
// geographic extent, and any matched pairs falling inside that area will be
// used in the computation of statistics.  Masking regions may be specified
// in the following ways:
//
//    - The "grid" entry is an array of named grids.  It contains a
//      comma-separated list of pre-defined NCEP grids over which to perform
//      verification.  An empty list indicates that no masking grids should be
//      used.  The standard NCEP grids are named "GNNN" where NNN indicates the
//      three digit grid number.  Supplying a value of "FULL" indicates that the
//      verification should be performed over the entire grid on which the data
//      resides.
//      http://www.nco.ncep.noaa.gov/pmb/docs/on388/tableb.html
//      The "grid" entry can be the gridded data file defining grid.
//
//    - The "poly" entry contains a comma-separated list of files that define
//      verification masking regions. These masking regions may be specified in
//      two ways: as a lat/lon polygon or using a gridded data file such as the
//      NetCDF output of the Gen-Vx-Mask tool.
//
//       - An ASCII file containing a lat/lon polygon.
//         Latitude in degrees north and longitude in degrees east.
//         The first and last polygon points are connected.
//         e.g. "MET_BASE/poly/EAST.poly" which consists of n points:
//              "poly_name lat1 lon1 lat2 lon2... latn lonn"
//
//         Several masking polygons used by NCEP are predefined in the
//         installed share/met/poly directory. Creating a new polygon is as
//         simple as creating a text file with a name for the polygon followed
//         by the lat/lon points which define its boundary. Adding a new masking
//         polygon requires no code changes and no recompiling. Internally, the
//         lat/lon polygon points are converted into x/y values in the grid. The
//         lat/lon values for the observation points are also converted into x/y
//         grid coordinates. The computations performed to check whether the
//         observation point falls within the polygon defined is done in x/y
//         grid space.
//
//       - The NetCDF output of the gen_vx_mask tool.
//
//       - Any gridded data file that MET can read may be used to define a
//         verification masking region. Users must specify a description of the
//         field to be used from the input file and, optionally, may specify a
//         threshold to be applied to that field. Once this threshold is applied,
//         any grid point where the resulting field is 0, the mask is turned off.
//         Any grid point where it is non-zero, the mask is turned on.
//         e.g. "sample.grib {name = \"TMP\"; level = \"Z2\";} >273"
//
//    - The "sid" entry is an array of strings which define groups of
//      observation station ID's over which to compute statistics. Each entry
//      in the array is either a filename of a comma-separated list.
//       - For a filename, the strings are whitespace-separated.  The first
//         string is the mask "name" and the remaining strings are the station
//         ID's to be used.
//       - For a comma-separated list, optionally use a colon to specify a name.
//         For "MY_LIST:SID1,SID2", name = MY_LIST and values = SID1 and SID2.
//       - For a comma-separated list of length one with no name specified, the
//         mask "name" and value are both set to the single station ID string.
//         For "SID1", name = SID1 and value = SID1.
//       - For a comma-separated list of length greater than one with no name
//         specified, the name is set to MASK_SID and the values are the station
//         ID's to be used.
//         For "SID1,SID2", name = MASK_SID and values = SID1 and SID2.
//       - The "name" of the station ID mask is written to the VX_MASK column
//         of the MET output files.
//
mask = {
   grid    = [ "FULL" ];
   poly    = [ "MET_BASE/poly/LMV.poly",
               "MET_BASE/out/gen_vx_mask/CONUS_poly.nc",
               "MET_BASE/sample_fcst/2005080700/wrfprs_ruc13_12.tm00_G212 \
               {name = \"TMP\"; level = \"Z2\";} >273"
             ];
   sid     = [ "CONUS.stations" ];
}

//
// The "ci_alpha" entry is an array of floats specifying the values for alpha
// to be used when computing confidence intervals.  Values of alpha must be
// between 0 and 1.  The confidence interval computed is 1 minus the alpha value.
// Therefore, an alpha value of 0.05 corresponds to a 95% confidence interval.
//
ci_alpha = [ 0.05, 0.10 ];

//
// The "boot" entry defines the parameters to be used in calculation of
// bootstrap confidence intervals. The interval variable indicates what method
// should be used for computing bootstrap confidence intervals:
//
//    - The "interval" entry specifies the confidence interval method:
//       - "BCA" for the BCa (bias-corrected percentile) interval method is
//         highly accurate but computationally intensive.
//       - "PCTILE" uses the percentile method which is somewhat less accurate
//         but more efficient.
//
//    - The "rep_prop" entry specifies a proportion between 0 and 1 to define
//      the replicate sample size to be used when computing percentile
//      intervals.  The replicate sample size is set to boot_rep_prop * n,
//      where n is the number of raw data points.
//
//      When computing bootstrap confidence intervals over n sets of matched
//      pairs, the size of the subsample, m, may be chosen less than or equal to
//      the size of the sample, n. This variable defines the size of m as a
//      proportion relative to the size of n.  A value of 1 indicates that the
//      size of the subsample, m, should be equal to the size of the sample, n.
//
//    - The "n_rep" entry defines the number of subsamples that should be taken
//      when computing bootstrap confidence intervals. This variable should be
//      set large enough so that when confidence intervals are computed multiple
//      times for the same set of data, the intervals do not change much.
//      Setting this variable to zero disables the computation of bootstrap
//      confidence intervals, which may be necessary to run MET in realtime or
//      near-realtime over large domains since bootstrapping is computationally
//      expensive. Setting this variable to 1000 indicates that bootstrap
//      confidence interval should be computed over 1000 subsamples of the
//      matched pairs.
//
//    - The "rng" entry defines the random number generator to be used in the
//      computation of bootstrap confidence intervals. Subsamples are chosen at
//      random from the full set of matched pairs. The randomness is determined
//      by the random number generator specified. Users should refer to detailed
//      documentation of the GNU Scientific Library for a listing of the random
//      number generators available for use.
//      http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Generator-Performance.html
//
//    - The "seed" entry may be set to a specific value to make the computation
//      of bootstrap confidence intervals fully repeatable. When left empty
//      the random number generator seed is chosen automatically which will lead
//      to slightly different bootstrap confidence intervals being computed each
//      time the data is run. Specifying a value here ensures that the bootstrap
//      confidence intervals will be reproducable over multiple runs on the same
//      computing platform.
//
boot = {
   interval = PCTILE;
   rep_prop = 1.0;
   n_rep    = 0;
   rng      = "mt19937";
   seed     = "";
}

//
// The "interp" entry is a dictionary that specifies what interpolation or
// smoothing (for the Grid-Stat tools) methods should be applied.
// This dictionary may include the following entries:
//
//    - The "field" entry specifies to which field(s) the interpolation method
//      should be applied.  This does not apply when doing point verification
//      with the Point-Stat or Ensemble-Stat tools:
//       - "FCST" to interpolate/smooth the forecast field.
//       - "OBS" to interpolate/smooth the observation field.
//       - "BOTH" to interpolate/smooth both the forecast and the observation.
//
//    - The "vld_thresh" entry specifies a number between 0 and 1. When
//      performing interpolation over some neighborhood of points the ratio of
//      the number of valid data points to the total number of points in the
//      neighborhood is computed. If that ratio is less than this threshold,
//      the matched pair is discarded. Setting this threshold to 1, which is the
//      default, requires that the entire neighborhood must contain valid data.
//      This variable will typically come into play only along the boundaries of
//      the verification region chosen.
//
//    - The "shape" entry may be set to SQUARE or CIRCLE to specify the shape
//      of the smoothing area.  This option is available only in Grid-Stat but
//      support will be added to the other MET tools in future releases.
//
//    - The "type" entry is an array of dictionaries, each specifying an
//      interpolation method.  Interpolation is performed over a N by N box
//      centered on each point, where N is the width specified.  Each of these
//      dictionaries must include:
//
//      - The "width" entry is an integer which specifies the dimension of the
//        interpolation box. The neighborhood is simply a square containing the
//        observation point. The width value specifies the width of that square.
//        A width value of 1 is interpreted as the nearest neighbor model grid
//        point to the observation point. A width of 2 defines a 2 x 2 square of
//        grid points around the observation point (the 4 closest model grid
//        points), while a width of 3 defines a 3 x 3 square of grid points
//        around the observation point, and so on.  For grid-to-grid comparisons,
//        the width must be odd.
//
//      - The "method" entry specifies the interpolation procedure to be
//        applied to the points in the box:
//         - MIN         for the minimum value
//         - MAX         for the maximum value
//         - MEDIAN      for the median value
//         - UW_MEAN     for the unweighted average value
//         - DW_MEAN     for the distance-weighted average value (weight = distance^-2)
//         - LS_FIT      for a least-squares fit
//         - BILIN       for bilinear interpolation (width = 2)
//         - NEAREST     for the nearest grid point (width = 1)
//         - BEST        for the value closest to the observation
//         - UPPER_LEFT  for the upper left grid point (width = 1)
//         - UPPER_RIGHT for the upper right grid point (width = 1)
//         - LOWER_RIGHT for the lower right grid point (width = 1)
//         - LOWER_LEFT  for the lower left grid point (width = 1)
//
//         The BUDGET and FORCE regridding options are not valid for interpolating.
//         For grid-to-grid comparisons, the only valid options are MIN, MAX, MEDIAN, and UW_MEAN.
//
interp = {
   field      = BOTH;
   vld_thresh = 1.0;
   shape      = SQUARE;

   type = [
      {
         method = UW_MEAN;
         width  = 1;
      }
   ];
}

//
// The "nbrhd" entry is a dictionary that is very similar to the "interp"
// entry.  It specifies information for computing neighborhood statistics in
// Grid-Stat.  This dictionary may include the following entries:
//
//    - The "vld_thresh" entry is described above.
//
//    - The "width" entry is as described above, and must be odd.
//
//    - The "cov_thresh" entry is an array of thresholds to be used when
//      computing categorical statistics for the neighborhood fractional
//      coverage field.
//
nbrhd = {
   width      = [ 1 ];
   cov_thresh = [ >=0.5 ];
   vld_thresh = 1.0;
}

//
// The "hira" entry is a dictionary that is very similar to the "interp" and
// "nbrhd" entries.  It specifies information for applying the High Resolution
// Assessment (HiRA) verification logic in Point-Stat.  HiRA is analogous to
// neighborhood verification but for point observations.  The HiRA logic
// converts scalar forecast values into a fractional coverage value which
// Point-Stat evaluates as if it were a probability forecast.  For each
// observation value, the forecast fractional coverage is computed as the ratio
// of forecast values around the observation that meet the categorical forecast
// threshold criteria.  If applying HiRA, users should enable matched pair or
// probabilistic line types (MPR, PCT, PSTD, PJC, or PRC) in the output_flag
// dictionary.  The number of HiRA output lines is determined by the number of
// categorical forecast thresholds and HiRA neighborhood widths chosen.
// This dictionary may include the following entries:
//
//    -  The "flag" entry is a boolean which toggles "hira"
//       on (TRUE) and off (FALSE).
//
//    - The "width" entry specifies the neighborhood size.  Since HiRA applies
//      to point observations, the width may be even or odd.
//
//    - The "vld_thresh" entry is as described above.
//
//    - The "cov_thresh" entry is an array of probabilistic thresholds used to
//      populate the Nx2 probabilistic contingency table written to the PCT
//      output line and used for computing probabilistic statistics.
//
hira = {
   flag       = FALSE;
   width      = [ 2, 3, 4, 5 ];
   vld_thresh = 1.0;
   cov_thresh = [ ==0.25 ];
}

//
// The "output_flag" entry is a dictionary that specifies what verification
// methods should be applied to the input data.  Options exist for each
// output line type from the MET tools.  Each line type may be set to one of:
//    - "NONE" to skip the corresponding verification method
//    - "STAT" to write the verification output only to the ".stat" output file
//    - "BOTH" to write to the ".stat" output file as well the optional
//      "_type.txt" file, a more readable ASCII file sorted by line type.
//
output_flag = {
   fho    = BOTH;  // Forecast, Hit, Observation Rates
   ctc    = BOTH;  // Contingency Table Counts
   cts    = BOTH;  // Contingency Table Statistics
   mctc   = BOTH;  // Multi-category Contingency Table Counts
   mcts   = BOTH;  // Multi-category Contingency Table Statistics
   cnt    = BOTH;  // Continuous Statistics
   sl1l2  = BOTH;  // Scalar L1L2 Partial Sums
   sal1l2 = BOTH;  // Scalar Anomaly L1L2 Partial Sums when climatological data is supplied
   vl1l2  = BOTH;  // Vector L1L2 Partial Sums
   val1l2 = BOTH;  // Vector Anomaly L1L2 Partial Sums when climatological data is supplied
   pct    = BOTH;  // Contingency Table Counts for Probabilistic Forecasts
   pstd   = BOTH;  // Contingency Table Statistics for Probabilistic Forecasts with Dichotomous outcomes
   pjc    = BOTH;  // Joint and Conditional Factorization for Probabilistic Forecasts
   prc    = BOTH;  // Receiver Operating Characteristic for Probabilistic Forecasts
   mpr    = BOTH;  // Matched Pair Data
   nbrctc = BOTH;  // Neighborhood Contingency Table Counts
   nbrcts = BOTH;  // Neighborhood Contingency Table Statistics
   nbrcnt = BOTH;  // Neighborhood Continuous Statistics
   isc    = BOTH;  // Intensity-Scale
   rhist  = BOTH;  // Rank Histogram
   phist  = BOTH;  // Probability Integral Transform Histogram
   orank  = BOTH;  // Observation Rank
   ssvar  = BOTH;  // Spread Skill Variance
}

//
// The "nc_pairs_flag" can be set either to a boolean value or a dictionary
// in either Grid-Stat, Wavelet-Stat or MODE. The dictionary (with slightly
// different entries for the various tools ... see the default config files)
// has individual boolean settings turning on or off the writing out of the
// various fields in the netcdf output file for the tool.  Setting all
// dictionary entries to false means the netcdf file will not be generated.
//
// "nc_pairs_flag" can also be set to a boolean value.  In this case, a value
// of true means to just accept the default settings (which will turn on
// the output of all the different fields).  A value of false means no
// netcdf output will be generated.
//
nc_pairs_flag   = {
   latlon     = TRUE;
   raw        = TRUE;
   diff       = TRUE;
   climo      = TRUE;
   weight     = FALSE;
   nbrhd      = FALSE;
   apply_mask = TRUE;
}

//
// The "ps_plot_flag" entry is a boolean value for Wavelet-Stat and MODE
// indicating whether a PostScript plot should be generated summarizing
// the verification.
ps_plot_flag = TRUE;

//
// The "grid_weight_flag" specifies how grid weighting should be applied
// during the computation of continuous statistics and partial sums.  It is
// meant to account for grid box area distortion and is often applied to global
// Lat/Lon grids.  It is only applied for grid-to-grid verification in Grid-Stat
// and Ensemble-Stat and is not applied for grid-to-point verification.
// Three grid weighting options are currently supported:
//
//    - "NONE" to disable grid weighting using a constant weight (default).
//    - "COS_LAT" to define the weight as the cosine of the grid point latitude.
//      This an approximation for grid box area used by NCEP and WMO.
//    - "AREA" to define the weight as the true area of the grid box (km^2).
//
// The weights are ultimately computed as the weight at each grid point divided
// by the sum of the weights for the current masking region.
//
grid_weight_flag = NONE;

//
// The "rank_corr_flag" entry is a boolean to indicate whether Kendall's Tau
// and Spearman's Rank Correlation Coefficients (in the CNT line type) should
// be computed.  Computing them over large datasets is computationally
// intensive and slows down the runtime significantly.
//
rank_corr_flag = FALSE;

//
// The "duplicate_flag" entry specifies how to handle duplicate point
// observations in Point-Stat and Ensemble-Stat:
//
//    - "NONE" to use all point observations (legacy behavior)
//    - "UNIQUE" only use a single observation if two or more observations match.
//             Matching observations are determined if they contain identical
//             latitude, longitude, level, elevation, and time information.
//             They may contain different observation values or station IDs
//
// The reporting mechanism for this feature can be activated by specifying
// a verbosity level of three or higher.  The report will show information
// about where duplicates were detected and which observations were used
// in those cases.
//
duplicate_flag = NONE;

//
// The "obs_summary" entry specifies how to compute statistics on
// observations that appear at a single location (lat,lon,level,elev)
// in Point-Stat and Ensemble-Stat.  Eight techniques are
// currently supported:
//
//    - "NONE" to use all point observations (legacy behavior)
//    - "NEAREST" use only the observation that has the valid
//      time closest to the forecast valid time
//    - "MIN" use only the observation that has the lowest value
//    - "MAX" use only the observation that has the highest value
//    - "UW_MEAN" compute an unweighted mean of the observations
//    - "DW_MEAN" compute a weighted mean of the observations based
//      on the time of the observation
//    - "MEDIAN" use the median observation
//    - "PERC" use the Nth percentile observation where N = obs_perc_value
//
// The reporting mechanism for this feature can be activated by specifying
// a verbosity level of three or higher.  The report will show information
// about where duplicates were detected and which observations were used
// in those cases.
//
obs_summary = NONE;

//
// Percentile value to use when obs_summary = PERC
//
obs_perc_value = 50;

//
// The "obs_quality" entry specifies the quality flag values that are to be
// retained and used for verification.  An empty list signifies that all
// point observations should be used, regardless of their quality flag value.
// The quality flag values will vary depending on the original source of the
// observations.  The quality flag values to retain should be specified as
// an array of strings, even if the values themselves are numeric.
//
obs_quality = [ "1", "2", "3", "9" ];

//
// The "met_data_dir" entry specifies the location of the internal MET data
// sub-directory which contains data files used when generating plots.  It
// should be set to the installed share/met directory so the MET tools can
// locate the static data files they need at run time.
//
met_data_dir = "MET_BASE";

//
// The "fcst_raw_plot" entry is a dictionary used by Wavelet-Stat and MODE
// containing colortable plotting information for the plotting of the raw
// forecast field:
//
//    - The "color_table" entry specifies the location and name of the
//      colortable file to be used.
//
//    - The "plot_min" and "plot_max" entries specify the range of data values.
//      If they are both set to 0, the MET tools will automatically rescale
//      the colortable to the range of values present in the data.  If they
//      are not both set to 0, the MET tools will rescale the colortable using
//      their values.
//
fcst_raw_plot = {
   color_table = "MET_BASE/colortables/met_default.ctable";
   plot_min = 0.0;
   plot_max = 0.0;
}

//
// The "obs_raw_plot", "wvlt_plot", and "object_plot" entries are dictionaries
// similar to the "fcst_raw_plot" described above.
//

//
// The "tmp_dir" entry is a string specifying the location where temporary
// files should be written.
//
tmp_dir = "/tmp";

//
// The "output_prefix" entry specifies a string to be included in the output
// file name.  The MET statistics tools construct output file names that
// include the tool name and timing information.  You can use this setting
// to modify the output file name and avoid naming conflicts for multiple runs
// of the same tool.
//
output_prefix  = "";

//
// The "version" entry specifies the version number of the configuration file.
// The configuration file version number should match the version number of
// the MET code being run.  This value should generally not be modified.
//
version = "V6.0";
