////////////////////////////////////////////////////////////////////////////////
//
// Configuration file overview.
//
////////////////////////////////////////////////////////////////////////////////

The configuration files that control many of the MET tools contain formatted
ASCII text.  This format has been updated for METv4.0.

Settings common to multiple tools are described in the top part of this README
file and settings specific to individual tools are described beneath the common
settings.  Please refer to the MET User's Guide in the "doc" directory for more
details about the settings if necessary.

A configuration file entry is an entry name, followed by an equal sign =,
followed by an entry value, and is terminated by a semicolon ;.  The
configuration file itself is one large dictionary consisting of entries, some of
which are dictionaries themselves.

The configuration file language supports the following data types:
   - Dictionary:
      - Grouping of one or more entries enclosed by curly braces {}.
   - Array:
      - List of one or more entries enclosed by square braces [].
      - Array elements are separated by commas.
   - String:
      - A character string enclosed by double quotation marks "".
   - Integer:
      - A numeric integer value.
   - Float:
      - A numeric float value.
   - Boolean:
      - A boolean value (TRUE or FALSE).
   - Threshold:
      - A threshold type (<, <=, ==, !-, >=, or >) followed by a numeric value.
      - The threshold type may also be specified using two letter abbreviations
        (lt, le, eq, ne, ge, gt).
   - Piecewise-Linear Function (currently used only by MODE):
      - A list of (x, y) points enclosed in parenthesis ().
      - The (x, y) points are *NOT* separated by commas.

The context of a configuration entry matters.  If an entry cannot be found in
the expected dictionary, the MET tools recursively search for that entry in the
parent dictionaries, all the way up to the top-level configuration file
dictionary.  If you'd like to apply the same setting across all cases, you can
simply specify it once at the top-level.  Alternatively, you can specify a
setting at the appropriate dictionary level to have finer control over the
behavior.

In order to make the configuration files more readable, several descriptive
integer types have been defined in the ConfigConstants file.  These integer
names may be used on the right-hand side for many configuration file entries.

Each of the configurable MET tools expects a certain set of configuration
entries.  Examples of the MET configuration files can be found in data/config
and scripts/config.

When you pass a configuration file to a MET tool, the tool actually parses three
different configuration files in the following order:
   (1) Reads data/config/ConfigConstants to define constants.
   (2) Reads the default configuration file for the tool from data/config.
   (3) Reads the user-specified configuration file from the command line.

Many of the entries from step (2) are overwritten by the user-specified entries
from step (3).  Therefore, the configuration file you pass in on the command
line really only needs to contain entries that differ from the defaults.

The configuration file language supports the use of environment variables. When
scripting up many calls to the MET tools, you may find it convenient to use them.
They are specified as ${ENV_VAR}, where ENV_VAR is the name of the environment
variable.

The MET_BASE variable is defined in the code at compilation time as the path
to the top-level MET directory.  MET_BASE may be used in the MET configuration
files when specifying paths and the appropriate path will be substituted in.
If MET_BASE is defined as an environment variable, its value will be used
instead of the one defined at compilation time.

An error in the syntax of a configuration file will result in an error from the
MET tool stating the location of the parsing error.

////////////////////////////////////////////////////////////////////////////////
//
// Configuration settings used by the MET tools.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// Settings common to multiple tools
//
////////////////////////////////////////////////////////////////////////////////

//
// The "model" entry specifies a name for the model being verified.  This name
// is written to the second column of the ASCII output generated.  If you're
// verifying multiple models, you should choose descriptive model names (no 
// whitespace) to distinguish between their output.
// e.g. model = [ "AHW4", "AHWI" ];
//
model = "WRF";

//
// The "fcst" entry is a dictionary containing information about the field(s)
// to be verified.  This dictionary may include the following entries:
//
//   - The "field" entry is an array of dictionaries, each specifying a
//     verification task.  Each of these dictionaries may include:
//
//      - The "name" entry specifies a name for the field.
//
//      - The "level" entry specifies level information for the field.
//
//      - Setting "name" and "level" is file-format specific.  See below.
//
//      - The "prob" entry is a boolean that specifies whether this field
//        contains probabilities.
//
//      - The "cat_thresh" entry is an array of thresholds to be used when
//        computing categorical statistics.
//
//   - The "file_type" entry specifies the input file type rather than letting
//     the code determine it itself.  For valid file_type values, see "File types"
//     in the data/config/ConfigConstants file.
//
//   - The "wind_thresh" entry is an array of thresholds used to filter wind
//     speed values when computing VL1L2 vector partial sums.  Only those U/V
//     pairs that meet this wind speed criteria will be included in the sums.
//     Setting this threshold to NA will result in all U/V pairs being used.
//
//   - The "init_time" entry specifies the initialization time in YYYYMMDD[_HH[MMSS]] 
//     format.  This entry can be included in the "fcst" entry as shown below or
//     included in the "field" entry if the user would like to use different 
//     initialization times for different fields.
//
//   - The "valid_time" entry specifies the valid time in YYYYMMDD[_HH[MMSS]] 
//     format.  This entry can be included in the "fcst" entry as shown below or
//     included in the "field" entry if the user would like to use different 
//     valid times for different fields.
//
//   - The "lead_time" entry specifies the lead time in HH[MMSS]
//     format.  This entry can be included in the "fcst" entry as shown below or
//     included in the "field" entry if the user would like to use different 
//     lead times for different fields.
//
// It is only necessary to use the "init_time", "valid_time", and/or "lead_time"
// settings when verifying a file containing data for multiple output times.
// For example, to verify a GRIB file containing data for many lead times, you
// could use "lead_time" specify the record to be verified.
//
// File-format specific settings for the "field" entry:
//
//    - GRIB1 and GRIB2:
//       - The "name" entry specifies a GRIB code number or abbreviation.
//         http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html
//       - The "level" entry specifies a level type and value:
//          - ANNN for accumulation interval NNN
//          - ZNNN for vertical level NNN
//          - ZNNN-NNN for a range of vertical levels
//          - PNNN for pressure level NNN in hPa
//          - PNNN-NNN for a range of pressure levels in hPa
//          - LNNN for a generic level type
//          - RNNN for a specific GRIB record number
//       - The "GRIB_lvl_typ" entry specifies the level type.
//       - The "GRIB_lvl_val1" and "GRIB_lvl_val2" entries specify the first
//         and second level values.
//       - The "GRIB1_ptv" entry specifies the GRIB1 parameter table version
//         number.
//       - The "GRIB1_rec" entry specifies the GRIB1 record number.
//       - The "GRIB2_disc" entry specifies the GRIB2 discipline code.
//       - The "GRIB2_parm_cat" entry specifies the parameter category code.
//       - The "GRIB2_parm" entry specifies the parameter code.
//
//    - NetCDF (from MET and Pinterp):
//       - The "name" entry specifies the NetCDF variable name.
//       - The "level" entry specifies the dimensions to be used:
//          - (i,...,j,*,*) for a single field, where i,...,j specifies fixed
//            dimension values and *,* specifies the two dimensions for the
//            gridded field.
//       e.g. 
//           field = [
//             {
//               name       = "QVAPOR";
//               level      = "(0,5,*,*)";
//             }
//           ];
//
//
fcst = {
   wind_thresh  = [ NA ];
   message_type = [ "ADPSFC" ];
   init_time    = "20120619_12";
   valid_time   = "20120620_00";
   lead_time    = "12";

   field = [
      {
        name       = "APCP";
        level      = [ "A03" ];
        cat_thresh = [ >0.0, >=5.0 ];
      }
   ];
};

//
// The "obs" entry specifies the same type of information as "fcst", but for
// the observation data.  It will often be set to the same things as "fcst",
// as shown in the example below.  However, when comparing forecast and
// observation files of different format types, this entry will need to be set
// in a non-trivial way.  The length of the "obs.field" array must match the
// length of the "fcst.field" array.
//
//   - The "message_type" entry is an array of point observation message types
//     to be used.  This only applies to the tools that verify against point
//     observations.  This may be specified once at the top-level "obs"
//     dictionary or separately for each "field" array element.  In the example
//     shown here, this is specified in the "fcst" dictionary and copied to "obs".
//
obs = fcst;

//
// The "mask_missing_flag" entry specifies how missing data should be handled
// in the Wavelet-Stat and MODE tools:
//    - "NONE" to perform no masking of missing data
//    - "FCST" to mask the forecast field with missing observation data
//    - "OBS" to mask the observation field with missing forecast data
//    - "BOTH" to mask both fields with missing data from the other
//
mask_missing_flag = BOTH;

//
// The "obs_window" entry is a dictionary specifying a beginning ("beg"
// entry) and ending ("end" entry) time offset values in seconds.  These time
// offsets are defined relative to a reference time t, as [t+beg, t+end].
// In PB2NC, the reference time is the PrepBufr files center time.  In
// Point-Stat and Ensemble-Stat, the reference time is the forecast valid time.
//
obs_window = {
   beg = -5400;
   end =  5400;
}

//
// The "mask" entry is a dictionary that specifies the verification masking
// regions to be used when computing statistics.  Each mask defines a
// geographic extent, and any matched pairs falling inside that area will be
// used in the computation of statistics.  Masking regions may be specified
// in the following ways:
//
//    - The "grid" entry is an array of named grids.  An empty list indicates
//      that no masking grids should be used.  The standard NCEP grids are
//      named "GNNN" where NNN indicates the three digit grid number.  Enter
//      "FULL" to score over the entire domain.
//      http://www.nco.ncep.noaa.gov/pmb/docs/on388/tableb.html
//
//    - The "poly" entry is an array of masking regions that may be specified
//      in the following ways:
//
//       - An ASCII file containing a lat/lon polygon.
//         Latitude in degrees north and longitude in degrees east.
//         By default, the first and last polygon points are connected.
//         e.g. "MET_BASE/data/poly/EAST.poly" which consists of n points:
//              "poly_name lat1 lon1 lat2 lon2... latn lonn"
//
//       - The NetCDF output of the gen_poly_mask tool.
//
//       - A gridded data file on the same grid as the forecast data followed
//         by a dictionary for the field to be used, and optionally, a
//         threshold to be applied.
//         e.g. "sample.grib {name = \"TMP\"; level = \"Z2\";} >273"
//
//    - The "sid" entry is an array of station ID groups.  Each element is
//      either the name of a single station ID or a station ID group file name.
//      A station ID group file consists of a name for the group followed by a
//      list of station ID's.
//
mask = {
   grid = [ "FULL" ];
   poly = [ "MET_BASE/data/poly/LMV.poly",
            "MET_BASE/out/gen_poly_mask/CONUS_poly.nc",
            "MET_BASE/data/sample_fcst/2005080700/wrfprs_ruc13_12.tm00_G212 \
            {name = \"TMP\"; level = \"Z2\";} >273"
          ];
   sid  = [ "CONUS.stations" ];
};

//
// The "ci_alpha" entry is an array of floats specifying the values for alpha
// to be used when computing confidence intervals.  Values of alpha must be
// between 0 and 1.
//
ci_alpha = [ 0.05, 0.10 ];

//
// The "boot" entry is a dictionary that specifies how bootstrap confidence
// intervals should be computed.  This dictionary may include the following
// entries:
//
//    - The "interval" entry specifies the confidence interval method:
//       - "BCA" for the BCa interval method is more accurate but slower.
//       - "PCTILE" uses the percentile method and is quicker.
//
//    - The "rep_prop" entry specifies a proportion between 0 and 1 to define
//      the replicate sample size to be used when computing percentile
//      intervals.  The replicate sample size is set to boot_rep_prop * n,
//      where n is the number of raw data points.
//
//    - The "n_rep" entry specifies the number of bootstrap replicates.  That
//      is the number of times each set of matched pair data should be
//      resampled when computing bootstrap confidence intervals.  A value of
//      zero disables the computation of bootstrap confidence intervals and
//      may speed up the runtime significantly.
//
//    - The "rng" entry specifies the name of the GSL random number generator.
//      http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Generator-Performance.html
//
//    - The "seed" entry specifies a seed value to be used when computing
//      bootstrap confidence intervals.  If left unspecified, the seed will
//      change for each run and the computed bootstrap confidence intervals
//      will not be reproducible.
//
boot = {
   interval = PCTILE;
   rep_prop = 1.0;
   n_rep    = 0;
   rng      = "mt19937";
   seed     = "";
};

//
// The "interp" entry is a dictionary that specifies what interpolation methods
// should be applied.  This dictionary may include the following entries:
//
//    - The "field" entry specifies to which field(s) the interpolation method
//      should be applied:
//       - "FCST" to interpolate/smooth the forecast field.
//       - "OBS" to interpolate/smooth the observation field.
//       - "BOTH" to interpolate/smooth both the forecast and the observation.
//
//    - The "vld_thresh" entry specifies a proportion between 0 and 1 to define
//      the required ratio of valid data points.  When interpolating, compute
//      a ratio of the number of valid data points to the total number of
//      points in the neighborhood.  If that ratio is less than this threshold,
//      skip the current point.
//
//    - The "type" entry is an array of dictionaries, each specifying an
//      interpolation method.  Interpolation is performed over a N by N box
//      centered on each point, where N is the width specified.  Each of these
//      dictionaries must include:
//
//      - The "width" entry specifies dimension of the interpolation box. For
//        grid-to-grid comparisons, the width must be odd.
//
//      - The "method" entry specifies the interpolation procedure to be
//        applied to the points in the box:
//           - "MIN" for the minimum value
//           - "MAX" for the maximum value
//           - "MEDIAN" for the median value
//           - "UW_MEAN" for the unweighted average value
//           - "DW_MEAN" for the distance-weighted average value
//           - "LS_FIT" for a least-squares fit
//           - "BILIN" for bilinear interpolation
//           - For grid-to-grid comparisons, only valid options are MIN, MAX,
//             MEDIAN, and UW_MEAN are options.
//
interp = {
   field      = BOTH;
   vld_thresh = 1.0;

   type = [
      {
         method = UW_MEAN;
         width  = 1;
      }
   ];
};

//
// The "nbrhd" entry is a dictionary that is very similar to the "interp"
// entry.  It specifies information for computing neighborhood statistics in
// Grid-Stat.  This dictionary may include the following entries:
//
//    - The "vld_thresh" entry is described above.
//
//    - The "width" entry is as described above, and must be odd.
//
//    - The "cov_thresh" entry is an array of thresholds to be used when
//      computing categorical statistics for the neighborhood fractional
//      coverage field.
//
nbrhd = {
   vld_thresh = 1.0;
   width      = [ 1 ];
   cov_thresh = [ >=0.5 ];
}

//
// The "output_flag" entry is a dictionary that specifies what verification
// methods should be applied to the input data.  Options exist for each
// output line type from the MET tools.  Each line type may be set to one of:
//    - "NONE" to skip the corresponding verification method
//    - "STAT" to write the verification output only to the ".stat" output file
//    - "BOTH" to write to the ".stat" output file as well the optional
//      "_type.txt" file, a more readable ASCII file sorted by line type.
//
output_flag = {
   fho    = BOTH;  // Forecast, Hit, Observation Rates
   ctc    = BOTH;  // Contingency Table Counts
   cts    = BOTH;  // Contingency Table Statistics
   mctc   = BOTH;  // Multi-category Contingency Table Counts
   mcts   = BOTH;  // Multi-category Contingency Table Statistics
   cnt    = BOTH;  // Continuous Statistics
   sl1l2  = BOTH;  // Scalar L1L2 Partial Sums
   sal1l2 = BOTH;  // Scalar Anomaly L1L2 Partial Sums when climatological data is supplied 
   vl1l2  = BOTH;  // Vector L1L2 Partial Sums
   val1l2 = BOTH;  // Vector Anomaly L1L2 Partial Sums when climatological data is supplied 
   pct    = BOTH;  // Contingency Table Counts for Probabilistic Forecasts
   pstd   = BOTH;  // Contingency Table Statistics for Probabilistic Forecasts with Dichotomous outcomes
   pjc    = BOTH;  // Joint and Conditional Factorization for Probabilistic Forecasts
   prc    = BOTH;  // Receiver Operating Characteristic for Probabilistic Forecasts
   mpr    = BOTH;  // Matched Pair Data 
   nbrctc = BOTH;  // Neighborhood Contingency Table Counts
   nbrcts = BOTH;  // Neighborhood Contingency Table Statistics
   nbrcnt = BOTH;  // Neighborhood Continuous Statistics
   isc    = BOTH;  // Intensity-Scale
   rhist  = BOTH;  // Rank Histogram
   orank  = BOTH;  // Observation Rank
   ssvar  = BOTH;  // Spread Skill Variance
};

//
// The "nc_pairs_flag" entry is a boolean value for Grid-Stat indicating
// whether a NetCDF file containing the gridded forecast, observation, and
// difference fields for all verification tasks should be created.
//
nc_pairs_flag = TRUE;

//
// The "ps_plot_flag" entry is a boolean value for Wavelet-Stat and MODE
// indicating whether a PostScript plot should be generated summarizing
// the verification.
//
ps_plot_flag = TRUE;

//
// The "rank_corr_flag" entry is a boolean to indicate whether Kendall's Tau
// and Spearman's Rank Correlation Coefficients (in the CNT line type) should
// be computed.  Computing them over large datasets is computationally
// intensive and slows down the runtime significantly.
//
rank_corr_flag = FALSE;

//
// The "duplicate_flag" entry specifies how to handle duplicate point
// observations in Point-Stat and Ensemble-Stat.  Three techniques are
// currently supported:
//
//    - "NONE" to use all point observations (legacy behavior)
//    - "UNIQUE" if two or more observations match identically except in the
//       station ID field, only use a single observation
//    - "SINGLE" if two or more observations appear at a single location
//      (lat, lon, level, elv), use only the observation that has the valid
//      time closest to the forecast valid time
//
// The reporting mechanism for this feature can be activated by specifying
// a verbosity level of three or higher.  The report will show information
// about where duplicates were detected and which observations were used
// in those cases.
//
duplicate_flag = NONE;

//
// The "obs_quality" entry specifies the quality flag values that are to be
// retained and used for verification.  An empty list signifies that all
// point observations should be used, regardless of their quality flag value.
// The quality flag values will vary depending on the original source of the 
// observations.  The quality flag values to retain should be specified as
// an array of strings, even if the values themselves are numeric.
//
obs_quality = [ "1", "2", "3", "9" ];

//
// The "met_data_dir" entry specifies the location of the MET data
// sub-directory which contains data files used when generating plots.
//
met_data_dir = "MET_BASE/data";

//
// The "fcst_raw_plot" entry is a dictionary used by Wavelet-Stat and MODE
// containing colortable plotting information for the plotting of the raw
// forecast field:
//
//    - The "color_table" entry specifies the location and name of the colortable file.
//
//    - The "plot_min" and "plot_max" entries specify the range of data values.
//      If they are both set to 0, the MET tools will automatically rescale
//      the colortable to the range of values present in the data.  If they
//      are not both set to 0, the MET tools will rescale the colortable using
//      their values.
//
fcst_raw_plot = {
   color_table = "MET_BASE/data/colortables/met_default.ctable";
   plot_min = 0.0;
   plot_max = 0.0;
};

//
// The "obs_raw_plot", "wvlt_plot", and "object_plot" entries are dictionaries
// similar to the "fcst_raw_plot" described above.
//

//
// The "tmp_dir" entry is a string specifying the location where temporary
// files should be written.
//
tmp_dir = "/tmp";

//
// The "output_prefix" entry specifies a string to be included in the output
// file name.  The MET statistics tools construct output file names that
// include the tool name and timing information.  You can use this setting
// to modify the output file name and avoid naming conflicts for multiple runs
// of the same tool.
//
output_prefix  = "";

//
// The "version" entry specifies the version number of the configuration file.
// The configuration file version number should match the version number of
// the MET code being run.  This value should generally not be modified.
//
version = "V4.0";

//
// The "jobs" entry is an array of STAT-Analysis or TCStat jobs to be performed.
// Each element in the array contains the specifications for a single analysis
// job to be performed.  The format for an analysis job is as follows:
//
//    -job job_name
//    OPTIONAL ARGS
//
//    Where "job_name" is set to one of the following:
//
//       "filter"
//          To filter out the STAT or TCMPR lines matching the job filtering criteria 
//          specified above and using the optional arguments below.  The 
//          output STAT lines are written to the file specified using the 
//          "-dump_row" argument.
//          Required Args: -dump_row
//
//       "summary"
//          To compute the mean, standard deviation, and percentiles
//          (0th, 10th, 25th, 50th, 75th, 90th, and 100th) for the statistic
//          specified using the "-line_type" and "-column" arguments.
//          For TCStat, the "-column" argument may be set to:
//             "TRACK" for track, along-track, and cross-track errors.
//             "WIND" for all wind radius errors.
//             "TI" for track and maximum wind intensity errors.
//             "AC" for along-track and cross-track errors.
//             "XY" for x-track and y-track errors.
//             "col" for a specific column name.
//             "col1-col2" for a difference of two columns.
//             "ABS(col or col1-col2)" for the absolute value.
//          Required Args: -line_type, -column
//          Optional Args (TCStat): -by column_name to specify case information
//                                  -out_alpha to override default alpha value
//
//       "aggregate"
//          To aggregate the STAT data for the STAT line type specified using
//          the "-line_type" argument.  The output of the job will be in the
//          same format as the input line type specified.  The following line
//          types may be aggregated:
//          -line_type FHO, CTC, MCTC,
//                     SL1L2, SAL1L2, VL1L2, VAL1L2,
//                     PCT, NBRCNT, NBRCTC, ISC, RHIST
//          Required Args: -line_type
//
//       "aggregate_stat"
//          To aggregate the STAT data for the STAT line type specified using
//          the "-line_type" argument.  The output of the job will be the line
//          type specified using the "-out_line_type" argument.  The valid
//          combinations of "-line_type" and "-out_line_type" are listed below.
//          -line_type FHO,   CTC,    -out_line_type CTS
//          -line_type MCTC           -out_line_type MCTS
//          -line_type SL1L2, SAL1L2, -out_line_type CNT
//          -line_type VL1L2, VAL1L2, -out_line_type WDIR (wind direction)
//          -line_type PCT,           -out_line_type PSTD, PJC, PRC
//          -line_type NBRCTC,        -out_line_type NBRCTS
//          -line_type MPR,           -out_line_type FHO, CTC, CTS,
//                                                   MCTC, MCTS, CNT,
//                                                   SL1L2, SAL1L2,
//                                                   PCT, PSTD, PJC, PRC
//          Required Args:
//             -line_type, -out_line_type
//          Additional Required Args for -line_type MPR:
//             -out_fcst_thresh, -out_obs_thresh
//             When -out_line_type FHO, CTC, CTS, MCTC, MCTS,
//                                 PCT, PSTD, PJC, PRC
//          Additional Optional Args for -line_type MPR:
//             -mask_grid, -mask_poly
//
//       "ss_index"
//          The skill score index job can be configured to compute a weighted
//          average of skill scores derived from a configurable set of
//          variables, levels, lead times, and statistics.  The skill score
//          index is computed using two models, a forecast model and a
//          reference model.  For each statistic in the index, a skill score
//          is computed as:
//             SS = 1 - (S[model]*S[model])/(S[reference]*S[reference])
//          Where S is the statistic.
//          Next, a weighted average is computed over all the skill scores.
//          Lastly, an index value is computed as:
//             Index = sqrt(1/(1-SS[avg]))
//          Where SS[avg] is the weighted average of skill scores.
//          Required Args:
//             Exactly 2 entries for -model, the forecast model and reference
//             For each term of the index:
//             -fcst_var, -fcst_lev, -fcst_lead, -line_type, -column, -weight
//             Where -line_type is CNT or CTS and -column is the statistic.
//             Optionally, specify other filters for each term, -fcst_thresh.
//
//       "go_index"
//          The GO Index is a special case of the skill score index consisting
//          of a predefined set of variables, levels, lead times, statistics,
//          and weights.
//          For lead times of 12, 24, 36, and 48 hours, it contains RMSE for:
//          - Wind Speed at the surface(b), 850(a), 400(a), 250(a) mb
//          - Dew point Temperature at the surface(b), 850(b), 700(b), 400(b) mB
//          - Temperature at the surface(b), 400(a) mB
//          - Height at 400(a) mB
//          - Sea Level Pressure(b)
//          Where (a) means weights of 4, 3, 2, 1 for the lead times, and
//          (b) means weights of 8, 6, 4, 2 for the lead times.
//          Required Args: None
//
//    Job command FILTERING options to further refine the STAT data:
//       Each optional argument may be used in the job specification multiple
//       times unless otherwise indicated. When multiple optional arguments of
//       the same type are indicated, the analysis will be performed over their
//       union:
//
//       "-model            name"
//       "-fcst_lead        HHMMSS"
//       "-obs_lead         HHMMSS"
//       "-fcst_valid_beg   YYYYMMDD[_HH[MMSS]]" (use once)
//       "-fcst_valid_end   YYYYMMDD[_HH[MMSS]]" (use once)
//       "-obs_valid_beg    YYYYMMDD[_HH[MMSS]]" (use once)
//       "-obs_valid_end    YYYYMMDD[_HH[MMSS]]" (use once)
//       "-fcst_init_beg    YYYYMMDD[_HH[MMSS]]" (use once)
//       "-fcst_init_end    YYYYMMDD[_HH[MMSS]]" (use once)
//       "-obs_init_beg     YYYYMMDD[_HH[MMSS]]" (use once)
//       "-obs_init_end     YYYYMMDD[_HH[MMSS]]" (use once)
//       "-fcst_init_hour   HH[MMSS]"
//       "-obs_init_hour    HH[MMSS]"
//       "-fcst_valid_hour" HH[MMSS]
//       "-obs_valid_hour"  HH[MMSS]
//       "-fcst_var         name"
//       "-obs_var          name"
//       "-fcst_lev         name"
//       "-obs_lev          name"
//       "-obtype           name"
//       "-vx_mask          name"
//       "-interp_mthd      name"
//       "-interp_pnts      n"
//       "-fcst_thresh      t"
//       "-obs_thresh       t"
//       "-cov_thresh       t"
//       "-alpha            a"
//       "-line_type        type"
//       "-column           name"
//       "-weight           value"
//
//   Job command FILTERING options used when the -line_type has been set to a
//   single value.  These options take two arguments, the name of the data
//   column to be used and the min, max, or exact value for that column.
//   If multiple column eq/min/max/str options are listed, the job will be
//   performed on their intersection:
//
//       "-column_min col_name value"
//       "-column_max col_name value"
//       "-column_eq  col_name value"
//       "-column_str col_name string" separate multiple filtering strings
//                                     with commas
//
//   Job command options to DEFINE the analysis job.  Unless otherwise noted,
//   these options may only be used ONCE per analysis job:
//
//       "-dump_row        path"
//
//       "-mask_grid       name"
//       "-mask_poly       file"
//
//       "-out_line_type   name"
//       "-out_fcst_thresh value" multiple for multi-category contingency tables
//                                and probabilistic forecasts
//       "-out_obs_thresh  value" multiple for multi-category contingency tables
//       "-out_alpha       value"
//
//       "-boot_interval   value"
//       "-boot_rep_prop   value"
//       "-n_boot_rep      value"
//       "-boot_rng        value"
//       "-boot_seed       value"
//
//       "-rank_corr_flag  value"
//       "-vif_flag        value"
//
jobs = [
   "-job filter         -line_type SL1L2                                            -vx_mask DTC165                                     -dump_row job_filter_SL1L2.stat",
   "-job summary        -line_type CNT   -alpha 0.050                                                                 -fcst_var TMP     -dump_row job_summary_ME.stat -column ME",
   "-job aggregate      -line_type SL1L2                                            -vx_mask DTC165   -vx_mask DTC166 -fcst_var TMP     -dump_row job_aggregate_SL1L2.stat",
   "-job aggregate_stat -line_type SL1L2 -out_line_type CNT                         -vx_mask DTC165   -vx_mask DTC166 -fcst_var TMP     -dump_row job_aggregate_stat_SL1L2_CNT.stat",
   "-job aggregate_stat -line_type MPR   -out_line_type CNT                         -vx_mask DTC165   -vx_mask DTC166 -fcat_var TMP     -dump_row job_aggregate_stat_MPR_CNT.stat",
   "-job aggregate      -line_type CTC                        -fcst_thresh <300.000 -vx_mask DTC165   -vx_mask DTC166 -fcst_var TMP     -dump_row job_aggregate_CTC.stat",
   "-job aggregate_stat -line_type CTC   -out_line_type CTS   -fcst_thresh <300.000 -vx_mask DTC165   -vx_mask DTC166 -fcst_var TMP     -dump_row job_aggregate_stat_CTC_CTS.stat",
   "-job aggregate      -line_type MCTC                       -column_eq N_CAT 4    -vx_mask DTC165   -vx_mask DTC166 -fcst_var APCP_24 -dump_row job_aggregate_MCTC.stat",
   "-job aggregate_stat -line_type MCTC  -out_line_type MCTS  -column_eq N_CAT 4    -vx_mask DTC165   -vx_mask DTC166 -fcst_var APCP_24 -dump_row job_aggregate_stat_MCTC_MCTS.stat",
   "-job aggregate      -line_type PCT                                              -vx_mask DTC165   -vx_mask DTC166                   -dump_row job_aggregate_PCT.stat",
   "-job aggregate_stat -line_type PCT   -out_line_type PSTD                        -vx_mask DTC165   -vx_mask DTC166                   -dump_row job_aggregate_stat_PCT_PSTD.stat",
   "-job aggregate      -line_type ISC                        -fcst_thresh >0.000   -vx_mask TILE_TOT                 -fcst_var APCP_12 -dump_row job_aggregate_ISC.stat",
   "-job aggregate      -line_type RHIST                      -obtype MC_PCP        -vx_mask HUC4_1605 -vx_mask HUC4_1803               -dump_row job_aggregate_RHIST.stat",
   "-job aggregate      -line_type SSVAR                      -obtype MC_PCP        -vx_mask HUC4_1605 -vx_mask HUC4_1803               -dump_row job_aggregate_SSVAR.stat",
   "-job aggregate_stat -line_type ORANK -out_line_type RHIST -obtype ADPSFC        -vx_mask HUC4_1605 -vx_mask HUC4_1803               -dump_row job_aggregate_stat_ORANK_RHIST.stat"
];

//
// Specify a comma-separated list of storm id's to be used:
//    2-letter basin, 2-digit cyclone number, 4-digit year
// An empty list indicates that all should be used.
//
// e.g. storm_id = [ "AL092011" ];
//
// This may also be set using basin, cyclone, and timing information below.
//
storm_id = [];

//
// Specify a comma-separated list of basins to be used.
// An empty list indicates that all should be used.
//   Valid basins: WP, IO, SH, CP, EP, AL, SL
//
// e.g. basin = [ "AL", "EP" ];
//
basin = [];

//
// Specify a comma-separated list of cyclone numbers (01-99) to be used.
// An empty list indicates that all should be used.
//
// e.g. cyclone = [ "01", "02", "03" ];
//
cyclone = [];


//
// Specify a comma-separated list of storm names to be used.
// An empty list indicates that all should be used.
//
// e.g. storm_name = [ "KATRINA" ];
//
storm_name = [];

//
// Specify a model initialization time window in YYYYMMDD[_HH[MMSS]] format
// or provide a list of specific initialization times to include or exclude.
// Tracks whose initial time meets the specified criteria will be used.
// An empty string indicates that all times should be used.
//
// e.g. init_beg = "20100101";
//      init_end = "20101231";
//      init_inc = [ "20101231_06" ];
//      init_exc = [ "20101231_00" ];
//
init_beg = "";
init_end = "";
init_inc = [];
init_exc = [];

//
// Specify a model valid time window in YYYYMMDD[_HH[MMSS]] format.
// Tracks for which all valid times fall within the time window will be used.
// An empty string indicates that all times should be used.
//
// e.g. valid_beg = "20100101";
//      valid_end = "20101231";
//
valid_beg = "";
valid_end = "";

//
// Specify a comma-separated list of model initialization hours to be used
// in HH[MMSS] format. An empty list indicates that all hours should be used.
//
// e.g. init_hour = [ "00", "06", "12", "18" ];
//
init_hour = [];

//
// Specify lat/lon polylines defining masking regions to be applied.
// Tracks whose initial location falls within init_mask will be used.
// Tracks for which all locations fall within valid_mask will be used.
//
// e.g. init_mask  = "MET_BASE/data/poly/EAST.poly";
//
init_mask  = "";
valid_mask = "";


////////////////////////////////////////////////////////////////////////////////
//
// Settings specific to individual tools
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
// Ascii2NcConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// Specify the time periods for the summarization.  Summarizations are
// centered on the defined times.
// Define beginning and ending time window in HH[MMSS].
// Step (the time between intervals) in seconds.
// Width of the time intervals in seconds.
// 
// e.g. beg = "00";
//      end = "235959";
//      step = 300;
//      width = 600;
//
// This example does a 10-minute time summary every 5 minutes throughout the
// day.  The first interval will be from 23:55:00 the previous day through
// 00:04:59 of the current day.  The second interval will be from 0:00:00
// through 00:09:59. And so on.
//
// The summaries will only be calculated for the specified grib codes.
// The supported summaries are "min" (minimum), "max" (maximum), "range",
// "mean", "stdev" (standard deviation), "median" and "p##" (percentile, with
// the desired percentile value specified in place of ##).
//

time_summary = {
  flag = FALSE;
  beg = "000000";
  end = "235959";
  step = 300;
  width = 600;
  grib_code = [ 11, 204, 211 ];
  type = [ "min", "max", "range", "mean", "stdev", "median", "p80" ];
}

////////////////////////////////////////////////////////////////////////////////
//
// EnsembleStatConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// The "ens" entry is a dictionary that specifies the fields for which ensemble
// products should be generated.  This is very similar to the "fcst" and "obs"
// entries.  This dictionary may include the following entries:
//
//    - The "ens_thresh" entry specifies a proportion between 0 and 1 to define
//      the required ratio of valid input ensemble member files.  If the ratio
//      of valid input ensemble files to expected ones is too lower, the tool
//      will error out.
//
//    - The "vld_thresh" entry specifies a proportion between 0 and 1 to
//      define the required ratio of valid data points.  When computing
//      ensemble products, if the ratio of valid data values is too lower, the
//      ensemble product will be set to bad data for that point.
//
//    - The "field" entry is as described above.
//
ens = {
   ens_thresh = 1.0;
   vld_thresh = 1.0;

   field = [
      {
         name       = "APCP";
         level      = "A03";
         cat_thresh = [ >0.0, >=5.0 ];
      }
   ];
}

//
// The "ensemble_flag" entry is a dictionary of boolean value indicating
// which ensemble products should be generated:
//    - "mean" for the simple ensemble mean
//    - "stdev" for the ensemble standard deviation
//    - "minus" for the mean minus one standard deviation
//    - "plus" for the mean plus one standard deviation
//    - "min" for the ensemble minimum
//    - "max" for the ensemble maximum
//    - "range" for the range of ensemble values
//    - "vld_count" for the number of valid ensemble members
//    - "frequency" for the ensemble relative frequency meeting a threshold
//    - "rank" for the rank of the gridded observation field
//
ensemble_flag = {
   mean      = TRUE;
   stdev     = TRUE;
   minus     = TRUE;
   plus      = TRUE;
   min       = TRUE;
   max       = TRUE;
   range     = TRUE;
   vld_count = TRUE;
   frequency = TRUE;
   rank      = TRUE;
};

//
// Random number generator used for random assignment of ranks when they 
// are tied.
// http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Generator-Performance.html
// 
rng = {
   type = "mt19937";
   seed = "";
}


////////////////////////////////////////////////////////////////////////////////
//
// MODEAnalysisConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// MODE line options are used to create filters that determine which of the MODE output
// lines that are read in, are kept.  The MODE line options are numerous.  They fall into
// seven categories: toggles, multiple set string options, multiple set integer options,
// integer max/min options, date/time max/min options, floating-point max/min options, and
// miscellaneous options.  In order to be applied, the options must be uncommented (remove
// the "//" marks) before running.  These options are described in subsequent sections.
//

//
// Toggles: The MODE line options described in this section are shown in pairs.  These
// toggles represent parameters that can have only one (or none) of two values.  Any 
// of these toggles may be left unspecified.  However, if neither option for toggle is
// indicated, the analysis will produce results that combine data from both toggles.
// This may produce unintended results.
//

// 
// This toggle indicates whether forecast or observed lines should be used for analysis. 
//
fcst      = FALSE;
obs       = FALSE;

// 
// This toggle indicates whether single object or object pair lines should be used.
//
single    = FALSE;
pair      = FALSE;

// 
// This toggle indicates whether simple object or object cluster object lines should be used.
//
simple    = FALSE;
cluster   = FALSE;

// 
// This toggle indicates whether matched or unmatched object lines should be used.
//
matched   = FALSE;
unmatched = FALSE;

//
// Multiple-set string options: The following options set various string attributes.  They
// can be set multiple times on the command line but must be separated by spaces.  Each of
// these options must be indicated as a string.  String values that include spaces may be
// used by enclosing the string in quotation marks.
//

//
// This options specifies which model to use
//
//model    = [];

//
// These two options specify thresholds for forecast and observations objects to be used in
// the analysis, respectively.
//
//fcst_thr = [];
//obs_thr  = [];

//
// These options indicate the names of variables to be used in the analysis for forecast
// and observed fields.
//
//fcst_var = [];
//obs_var = [];

//
// These options indicate vertical levels for forecast and observed fields to be used in 
// the analysis.
//
//fcst_lev = [];
//obs_lev = [];

//
// Multiple-set integer options: The following options set various integer attributes. 
// Each of the following options may only be indicated as an integer.
//

//
// These options are integers of the form HH[MMSS] specifying an (hour-minute-second)
// lead time.
//
//fcst_lead       = [];
//obs_lead       = [];

//
// These options are integers of the form HH[MMSS] specifying an (hour-minute-second)
// valid hour.
//
//fcst_valid_hour = [];
//obs_valid_hour = [];

//
// These options are integers of the form HH[MMSS] specifying an (hour-minute-second)
// model initialization hour.
//
//fcst_init_hour  = [];
//obs_init_hour  = [];

//
// These options are integers of the form HHMMSS specifying an (hour-minute-second)
// accumulation time.
//
//fcst_accum      = [];
//obs_accum      = [];

//
// These options indicate the convolution radius used for forecast of observed objects,
// respectively.
//
//fcst_rad        = [];
//obs_rad        = [];

//
// Integer max/min options: These options set limits on various integer attributes. 
// Leaving a maximum value unset means no upper limit is imposed on the value of 
// the attribute.  The option works similarly for minimum values.
//

//
// These options are used to indicate minimum/maximum values for the area attribute
// to be used in the analysis.
//
//area_min              = 0;
//area_max              = 0;

//
// These options are used to indicate minimum/maximum values accepted for the area filter.
// The area filter refers to the number of non-zero values of the raw data found within
// the object.
//
//area_filter_min       = 0;
//area_filter_max       = 0;

//
// These options refer to the minimum/maximum values accepted for the intersection area
// attribute.
//
//intersection_area_min = 0;
//intersection_area_max = 0;

//
// These options refer to the minimum/maximum union area values accepted for analysis.
//
//union_area_min        = 0;
//union_area_max        = 0;

//
// These options refer to the minimum/maximum values for symmetric difference for objects
// to be used in the analysis.
//
//symmetric_diff_min    = 0;
//symmetric_diff_max    = 0;

//
// Date/time max/min options: These options set limits on various date/time attributes. 
// The values can be specified in one of three ways:  First, the options may be indicated
// by a string of the form YYYMMDD_HHMMSS.  This specifies a complete calendar date and
// time.  Second, they may be indicated by a string of the form YYYYMMMDD_HH.  Here, the
// minutes and seconds are assumed to be zero.  The third way of indicating date/time 
// attributes is by a string of the form YYYMMDD.  Here, hours, minutes, and seconds are
// assumed to be zero.
//

//
// These options indicate minimum/maximum values for the forecast valid time.
//
//fcst_valid_min = "";
//fcst_valid_max = "";

//
// These options indicate minimum/maximum values for the observation valid time.
//
//obs_valid_min  = "";
//obs_valid_max  = "";

//
// These options indicate minimum/maximum values for the forecast initialization time.
//
//fcst_init_min  = "";
//fcst_init_max  = "";

//
// These options indicate minimum/maximum values for the observation initialization time.
//
//obs_init_min   = "";
//obs_init_max   = "";

//
// Floating-point max/min options: Setting limits on various floating-point attributes.
// One may specify these as integers (i.e., without a decimal point), if desired.  The 
// following pairs of options indicate minimum and maximum values for each MODE attribute
// that can be described as a floating-point number.  Please refer to "The MODE Tool" 
// section on attributes in the MET User's Guide for a description of these attributes.
//

//centroid_x_min                 = 0.0;
//centroid_x_max                 = 0.0;

//centroid_y_min                 = 0.0;
//centroid_y_max                 = 0.0;

//centroid_lat_min               = 0.0;
//centroid_lat_max               = 0.0;

//centroid_lon_min               = 0.0;
//centroid_lon_max               = 0.0;

//axis_ang_min                   = 0.0;
//axis_ang_max                   = 0.0;

//length_min                     = 0.0;
//length_max                     = 0.0;

//width_min                      = 0.0;
//width_max                      = 0.0;

//aspect_ratio_min               = 0.0;
//aspect_ratio_max               = 0.0;

//curvature_min                  = 0.0;
//curvature_max                  = 0.0;

//curvature_x_min                = 0.0;
//curvature_x_max                = 0.0;

//curvature_y_min                = 0.0;
//curvature_y_max                = 0.0;

//complexity_min                 = 0.0;
//complexity_max                 = 0.0;

//intensity_10_min               = 0.0;
//intensity_10_max               = 0.0;

//intensity_25_min               = 0.0;
//intensity_25_max               = 0.0;

//intensity_50_min               = 0.0;
//intensity_50_max               = 0.0;

//intensity_75_min               = 0.0;
//intensity_75_max               = 0.0;

//intensity_90_min               = 0.0;
//intensity_90_max               = 0.0;

//intensity_user_min             = 0.0;
//intensity_user_max             = 0.0;

//intensity_sum_min              = 0.0;
//intensity_sum_max              = 0.0;

//centroid_dist_min              = 0.0;
//centroid_dist_max              = 0.0;

//boundary_dist_min              = 0.0;
//boundary_dist_max              = 0.0;

//convex_hull_dist_min           = 0.0;
//convex_hull_dist_max           = 0.0;

//angle_diff_min                 = 0.0;
//angle_diff_max                 = 0.0;

//area_ratio_min                 = 0.0;
//area_ratio_max                 = 0.0;

//intersection_over_area_min     = 0.0;
//intersection_over_area_max     = 0.0;

//complexity_ratio_min           = 0.0;
//complexity_ratio_max           = 0.0;

//percentile_intensity_ratio_min = 0.0;
//percentile_intensity_ratio_max = 0.0;

//interest_min                   = 0.0;
//interest_max                   = 0.0;

////////////////////////////////////////////////////////////////////////////////
//
// MODEConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// The object definition settings for MODE are contained within the "fcst" and
// "obs" entries:
//
//    - The "raw_thresh" entry specifies a threshold to be applied to the raw
//      data fields.  Any values not meeting the threshold are set to bad data.
//
//    - The "conv_radius" entry specifies the convolution radius in grid
//      squares.  The larger the convolution radius, the smoother the objects.
//
//    - The "conv_thresh" entry specifies the convolution threshold used to
//      define MODE objects.  The lower the threshold, the larger the objects.
//
//    - The "vld_thresh" entry is described above.
//
//    - The "area_thresh" entry specifies a threshold in grid squares for the
//      area of MODE objects.  Any objects not meeting this threshold are
//      discarded.
//
//    - The "inten_perc_value" entry specifies the intensity percentile value
//      of interest between 0 and 100.
//
//    - The "inten_perc_thresh" entry specifies a threshold for the percentile
//      intensity of each MODE object.  Any objects not meeting this threshold
//      are discarded.
//
//    - The "merge_thresh" entry specifies a lower convolution threshold used
//      when the double-thresholding merging method is applied.
//
//    - The "merge_flag" entry specifies the merging methods to be applied:
//       - "NONE" for no merging
//       - "THRESH" for the double-threshold merging method.  Merge objects
//         that would be part of the same object at the lower threshold.
//       - "ENGINE" for the fuzzy logic approach comparing the field to itself
//       - "BOTH" for both the double-threshold and engine merging methods
//
fcst = {
   field = {
      name  = "APCP";
      level = "A03";
   };

   raw_thresh        = >=0.0;
   conv_radius       = 60.0/grid_res; // in grid squares
   conv_thresh       = >=5.0;
   vld_thresh        = 0.5;
   area_thresh       = >=0.0;
   inten_perc_value  = 100;
   inten_perc_thresh = >=0.0;
   merge_thresh      = >=1.25;
   merge_flag        = THRESH;
};

//
// The grid_res variable is the nominal spacing for each grid square in kilometers.
// The variable is not used directly in the code, but subsequent variables in the 
// configuration files are defined in terms of it.  Therefore, setting the appropriately
// will help ensure that appropriate default values are used for these variables.
//
grid_res = 4;

//
// The "match_flag" entry specifies the matching method to be applied:
//    - "NONE" for no matching between forecast and observation objects
//    - "MERGE_BOTH" for matching allowing additional merging in both fields.
//      If two objects in one field match the same object in the other field,
//      those two objects are merged.
//    - "MERGE_FCST" for matching allowing only additional forecast merging
//    - "NO_MERGE" for matching with no additional merging in either field
//
match_flag = MERGE_BOTH;

//
// The "max_centroid_dist" entry specifies the maximum allowable distance in
// grid squares between the centroids of objects for them to be compared.
// Setting this to a reasonable value speeds up the runtime enabling MODE to
// skip unreasonable object comparisons.
//
max_centroid_dist = 800.0/grid_res;

//
// The weight variables control how much weight is assigned to each pairwise 
// attribute when computing a total interest value for object pairs. The weights
// need not sum to any particular value but must be non-negative.  When the 
// total interest value is computed, the weighted sum is normalized by the 
// sum of the weights listed.
//
weight = {
   centroid_dist    = 2.0;
   boundary_dist    = 4.0;
   convex_hull_dist = 0.0;
   angle_diff       = 1.0;
   area_ratio       = 1.0;
   int_area_ratio   = 2.0;
   complexity_ratio = 0.0;
   inten_perc_ratio = 0.0;
   inten_perc_value = 50;
}

//
// The set of interest function variables listed define which values are of interest
// for each pairwise attribute measured.  The interest functions may be defined as
// a piecewise linear function or as an algebraic expression.  A piecewise linear
// function is defined by specifying the corner points of its graph.  An algebraic
// function may be defined in terms of several built-in mathematical functions.
//
interest_function = {

   centroid_dist = (
      (            0.0, 1.0 )
      (  60.0/grid_res, 1.0 )
      ( 600.0/grid_res, 0.0 )
   );

   boundary_dist = (
      (            0.0, 1.0 )
      ( 400.0/grid_res, 0.0 )
   );

   convex_hull_dist = (
      (            0.0, 1.0 )
      ( 400.0/grid_res, 0.0 )
   );

   angle_diff = (
      (  0.0, 1.0 )
      ( 30.0, 1.0 )
      ( 90.0, 0.0 )
   );

   corner   = 0.8;
   ratio_if = (
      (    0.0, 0.0 )
      ( corner, 1.0 )
      (    1.0, 1.0 )
   );

   area_ratio = ratio_if;

   int_area_ratio = (
      ( 0.00, 0.00 )
      ( 0.10, 0.50 )
      ( 0.25, 1.00 )
      ( 1.00, 1.00 )
   );

   complexity_ratio = ratio_if;

   inten_perc_ratio = ratio_if;
}

//
// The total_interest_thresh variable should be set between 0 and 1.  This threshold
// is applied to the total interest values computed for each pair of objects and
// is used in determining matches.
//
total_interest_thresh = 0.7;

//
// The print_interest_thresh variable determines which pairs of object attributes will
// be written to the output object attribute ASCII file.  The user may choose to set
// the print_interest_thresh to the same value as the total_interest_thresh, meaning
// that only object pairs that actually match are written to the output file. When set 
// to zero, all object pair attributes will be written as long as the distance between
// the object centroids is less than the max_centroid_dist variable.
//
print_interest_thresh = 0.0;

//
// The MODE tool is not able to define objects that touch the edge of the grid.  After
// the convolution step is performed the outer columns and rows of data are zeroed out
// to enable MODE to identify objects.  The zero_border_size variable specifies how 
// many outer columns and rows of data are to be zeroed out.
//
zero_border_size = 1;

//
// When applied, the plot_valid_flag variable indicates that only the region containing
// valid data after masking is applied should be plotted. TRUE indicates the entire domain
// should be plotted; FALSE indicates only the region containing valid data after masking 
// should be plotted.
//
plot_valid_flag = FALSE;

//
// When applied, the plot_gcarc_flag variable indicates that the edges of polylines should
// be plotted using great circle arcs as opposed to straight lines in the grid. 
//
plot_gcarc_flag = FALSE;

//
// The ct_stats_flag can be set to TRUE or FALSE to produce additional output, in the form
// of contingency table counts and statistics.
//
ct_stats_flag   = TRUE;

////////////////////////////////////////////////////////////////////////////////
//
// PB2NCConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// The PB2NC tool filters out observations from PrepBufr files using the
// following criteria:
//  (1) by message type: supply a list of PrepBufr message types to retain
//  (2) by station id: supply a list of observation stations to retain
//  (3) by valid time: supply the beginning and ending time offset values
//      in the obs_window entry described above.
//  (4) by location: use the "mask" entry described below to supply either 
//      an NCEP masking grid, a masking lat/lon polygon or a file to a 
//      mask lat/lon polygon
//  (5) by elevation: supply min/max elevation values
//  (6) by report type: supply a list of report types to retain by using 
//      pb_report_type and in_report_type entries described below
//  (7) by instrument type: supply a list of instrument type to
//      retain
//  (8) by vertical level: supply beg/end vertical levels by using the 
//      level_range entry described below
//  (9) by variable type: supply a list of observation variable types to
//      retain by using the obs_grib_code entry described below
// (11) by quality mark: supply a quality mark threshold
// (12) Flag to retain values for all quality marks, or just the first
//      quality mark (highest): use the event_stack_flag described below
// (13) by data level category: supply a list of category types to
//      retain.
//
//      0 - Surface level (mass reports only)
//      1 - Mandatory level (upper-air profile reports)
//      2 - Significant temperature level (upper-air profile reports)
//      2 - Significant temperature and winds-by-pressure level
//          (future combined mass and wind upper-air reports)
//      3 - Winds-by-pressure level (upper-air profile reports)
//      4 - Winds-by-height level (upper-air profile reports)
//      5 - Tropopause level (upper-air profile reports)
//      6 - Reports on a single level
//          (e.g., aircraft, satellite-wind, surface wind,
//           precipitable water retrievals, etc.)
//      7 - Auxiliary levels generated via interpolation from spanning levels
//          (upper-air profile reports)
//

//
// The "message_type" entry is an array of message types to be retained.  An
// empty list indicates that all should be retained.
//
// List of valid message types:
//    ADPUPA AIRCAR AIRCFT ADPSFC ERS1DA GOESND GPSIPW
//    MSONET PROFLR QKSWND RASSDA SATEMP SATWND SFCBOG
//    SFCSHP SPSSMI SYNDAT VADWND
//    ANYAIR (= AIRCAR, AIRCFT)
//    ANYSFC (= ADPSFC, SFCSHP, ADPUPA, PROFLR)
//    ONLYSF (= ADPSFC, SFCSHP)
//
//    e.g. message_type[] = [ "ADPUPA", "AIRCAR" ];
//
// http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_1.htm
//
message_type = [];

//
// The "station_id" entry is an array of station ids to be retained.  An empty
// list indicates that all stations should be retained.
//
// e.g. station_id = [ "KDEN" ];
//
station_id = [];

//
// The "elevation_range" entry is a dictionary which contains "beg" and "end"
// entries specifying the range of observing locations elevations to be
// retained.
//
elevation_range = {
   beg =  -1000;
   end = 100000;
}

//
// The "pb_report_type" entry is an array of PrepBufr report types to be
// retained.  An empty list indicates that all should be retained.
//
// http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_4.htm
//
pb_report_type  = [];

//
// The "in_report_type" entry is an array of input report type values to be
// retained.  An empty list indicates that all should be retained.
//
// http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_6.htm
//
in_report_type = [];

//
// The "instrument_type" entry is an array of instrument types to be retained.
// An empty list indicates that all should be retained.
//
instrument_type = [];

//
// The "level_range" entry is a dictionary which contains "beg" and "end"
// entries specifying the range of vertical levels (1 to 255) to be retained.
//
level_range = {
   beg = 1;
   end = 255;
}

//
// The "level_category" entry is an array of integers specifying which level
// categories should be retained:
//    0 = Surface level (mass reports only)
//    1 = Mandatory level (upper-air profile reports)
//    2 = Significant temperature level (upper-air profile reports)
//    2 = Significant temperature and winds-by-pressure level
//        (future combined mass and wind upper-air reports)
//    3 = Winds-by-pressure level (upper-air profile reports)
//    4 = Winds-by-height level (upper-air profile reports)
//    5 = Tropopause level (upper-air profile reports)
//    6 = Reports on a single level
//        (e.g., aircraft, satellite-wind, surface wind,
//         precipitable water retrievals, etc.)
//    7 = Auxiliary levels generated via interpolation from spanning levels
//        (upper-air profile reports)
// An empty list indicates that all should be retained.
//
// http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_1.htm
//
level_category = [];

//
// The "obs_grib_code" entry is an array of  strings containing grib codes or
// corresponding grib code abbreviations to be retained or derived from the
// available observations.
//
// GRIB Codes to be RETAINED:
//    SPFH or 51 for Specific Humidity in kg/kg
//    TMP  or 11 for Temperature in K
//    HGT  or 7  for Height in meters
//    UGRD or 33 for the East-West component of the wind in m/s
//    VGRD or 34 for the North-South component of the wind in m/s
//
// GRIB Codes to be DERIVED:
//    DPT   or 17 for Dew point Temperature in K
//    WIND  or 32 for Wind Speed in m/s
//    RH    or 52 for Relative Humidity in %
//    MIXR  or 53 for Humidity Mixing Ratio in kg/kg
//    PRMSL or  2 for Pressure Reduced to Mean Sea Level in Pa
//
// http://www.nco.ncep.noaa.gov/pmb/docs/on388/table2.html
//
obs_grib_code = [ "SPFH", "TMP", "HGT", "UGRD", "VGRD" ];

//
// The "quality_mark_thresh" entry specifies the maximum quality mark value
// to be retained.  Observations with a quality mark LESS THAN OR EQUAL TO
// this threshold will be retained, while observations with a quality mark
// GREATER THAN this threshold will be discarded.
//
// http://www.emc.ncep.noaa.gov/mmb/data_processing/prepbufr.doc/table_7.htm
//
quality_mark_thresh = 2;

//
// The "event_stack_flag" entry is set to "TOP" or "BOTTOM" to
// specify whether observations should be drawn from the top of the event
// stack (most quality controlled) or the bottom of the event stack (most raw).
//
event_stack_flag = TOP;

////////////////////////////////////////////////////////////////////////////////
//
// SeriesAnalysisConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// Number of grid points to be processed concurrently.  Set smaller to use
// less memory but increase the number of passes through the data.
//
block_size = 1024;

//
// Ratio of valid matched pairs to compute statistics for a grid point
//
vld_thresh = 1.0;

//
// Statistical output types
//
output_stats = {
   fho    = [];
   ctc    = [];
   cts    = [];
   mctc   = [];
   mcts   = [];
   cnt    = [ "RMSE", "FBAR", "OBAR" ];
   sl1l2  = [];
   pct    = [];
   pstd   = [];
   pjc    = [];
   prc    = [];
};

////////////////////////////////////////////////////////////////////////////////
//
// STATAnalysisConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// The "vif_flag" entry is a boolean to indicate whether a variance inflation
// factor should be computed when aggregating a time series of contingency
// table counts or partial sums.  The VIF is used to adjust the normal
// confidence intervals computed for the aggregated statistics.
//
vif_flag = FALSE;

////////////////////////////////////////////////////////////////////////////////
//
// TCPairsConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// Specify whether the code should check for duplicate ATCF lines when
// building tracks.  Setting this to FALSE makes the parsing of tracks quicker.
//
// e.g. check_dup = FALSE;
//
check_dup = FALSE;

//
// Specify whether special processing should be performed for interpolated
// models with 12-hour spacing.  For model with a name ending in 'I' (e.g. AHWI)
// search for the corresponding track whose model name ends in '2' (e.g. AHW2)
// and merge its track points into the interpolated model's track.
//
// e.g. interp12 = TRUE;
//
interp12 = TRUE;

//
// Specify how consensus forecasts should be defined:
//   name    = consensus model name
//   members = array of consensus member model names
//   required = array of true/false for each member
//             if empty, default is false
//   min_req = minimum number of members required for the consensus
//
// e.g.
//    consensus = [
//       {
//          name     = "CON1";
//          members  = [ "MOD1", "MOD2", "MOD3" ];
//          required = [ true, false, false ];
//          min_req  = 2;
//       }
//    ];
//
consensus = [];

//
// Specify a comma-separated list of forecast lag times to be used in HH[MMSS]
// format.  For each ADECK track identified, a lagged track will be derived
// for each entry listed.
//
// e.g. lag_time = [ "06", "12" ];
//
lag_time = [];

//
// Specify comma-separated lists of CLIPER/SHIFOR baseline forecasts to be
// derived from the BEST and operational (CARQ) tracks.
// Derived from BEST tracks: BCLP, BCS5, BCD5, BCLA
// Derived from CARQ tracks: OCLP, OCS5, OCD5, OCDT
//
// e.g. base_baseline = [ "BCLP", "BCS5", "BCD5", "BCLA" ];
//      oper_baseline = [ "OCLP", "OCS5", "OCD5", "OCDT" ];
//
best_baseline = [];
oper_baseline = [];

//
// Specify whether only those track points common to both the ADECK and BDECK
// tracks should be written out.
//
// e.g. match_points = FALSE;
//
match_points = FALSE;

//
// Specify the NetCDF output of the gen_dland tool containing a gridded
// representation of the minimum distance to land.
//
dland_file = "MET_BASE/data/tc_data/dland_nw_hem_tenth_degree.nc";

//
// Specify watch/warning information.  Specify an ASCII file containing
// watch/warning information to be used.  At each track point, the most severe
// watch/warning status in effect, if any, will be written to the output.
// Also specify a time offset in seconds to be added to each watch/warning
// time processed.  NHC applies watch/warning information to all track points
// occurring 4 hours (-14400 second) prior to the watch/warning time.
//
watch_warn = {
   file_name   = "MET_BASE/data/tc_data/wwpts_us.txt";
   time_offset = -14400;
};

////////////////////////////////////////////////////////////////////////////////
//
// TCStatConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// Stratify by the AMODEL or BMODEL columns.
// Specify comma-separated lists of model names to be used for all analyses
// performed.  May add to this list using the "-amodel" and "-bmodel"
// job command options.
// e.g. amodel = [ "AHW4" ];
//      bmodel = [ "BEST" ];
//
amodel = [];
bmodel = [];

//
// Stratify by the VALID times.
// Define beginning and ending time windows in YYYYMMDD[_HH[MMSS]]
// or provide a list of specific valid times to include or exclude.
// May modify using the "-valid_beg", "-valid_end", "-valid_inc",
// and "-valid_exc" job command options.
//
// e.g. valid_beg = "20100101";
//      valid_end = "20101231_12";
//      valid_inc = [ "20101231_06" ];
//      valid_exc = [ "20101231_00" ];
//
valid_beg = "";
valid_end = "";
valid_inc = [];
valid_exc = [];

//
// Stratify by the initialization and valid hours and lead time.
// Specify a comma-separated list of initialization hours,
// valid hours, and lead times in HH[MMSS] format.
// May add using the "-init_hour", "-valid_hour", and "-lead"
// job command options.
//
// e.g. init_hour  = [ "00" ];
//      valid_hour = [ "12" ];
//      lead       = [ "24", "36" ];
//
init_hour  = [];
valid_hour = [];
lead       = [];

//
// Stratify by the LINE_TYPE column.  May add using the "-line_type"
// job command option.
//
// e.g. line_type = [ "TCMPR" ];
//
line_type = [];

//
// Stratify by checking the watch/warning status for each track point
// common to both the ADECK and BDECK tracks. If the watch/warning status
// of any of the track points appears in the list, retain the entire track.
// Individual watch/warning status by point may be specified using the
// -column_str options below, but this option filters by the track maximum.
// May add using the "-track_watch_warn" job command option.
// The value "ALL" matches HUWARN, TSWARN, HUWATCH, and TSWATCH.
//
// e.g. track_watch_warn = [ "HUWATCH", "HUWARN" ];
//
track_watch_warn = [];

//
// Stratify by applying thresholds to numeric data columns.
// Specify a comma-separated list of columns names and thresholds
// to be applied.  May add using the "-column_thresh name thresh" job command
// options.
//
// e.g. column_thresh_name = [ "ADLAND", "BDLAND" ];
//      column_thresh_val  = [ >200,     >200     ];
//
column_thresh_name = [];
column_thresh_val  = [];

//
// Stratify by performing string matching on non-numeric data columns.
// Specify a comma-separated list of columns names and values
// to be checked.  May add using the "-column_str name string" job command
// options.
//
// e.g. column_str_name = [ "LEVEL", "LEVEL" ];
//      column_str_val  = [ "HU",    "TS"    ];
//
column_str_name = [];
column_str_val  = [];

//
// Just like the column_thresh options above, but apply the threshold only
// when lead = 0.  If lead = 0 value does not meet the threshold, discard
// the entire track.  May add using the "-init_thresh name thresh" job command
// options.
//
// e.g. init_thresh_name = [ "ADLAND" ];
//      init_thresh_val  = [ >200     ];
//
init_thresh_name = [];
init_thresh_val  = [];

//
// Just like the column_str options above, but apply the string matching only
// when lead = 0.  If lead = 0 string does not match, discard the entire track.
// May add using the "-init_str name thresh" job command options.
//
// e.g. init_str_name = [ "LEVEL" ];
//      init_str_val  = [ "HU"    ];
//
init_str_name = [];
init_str_val  = [];

//
// Stratify by the ADECK and BDECK distances to land.  Once either the ADECK or
// BDECK track encounters land, discard the remainder of the track.
//
// e.g. water_only = false;
//
water_only = false;

//
// Specify whether only those track points for which rapid intensification
// occurred in the BDECK track between the current time and 24-hours prior
// should be retained. Define rapid intensification by thresholding the change
// in maximum windspeed.
// May modify using the "-rapid_inten" and "-rapid_inten_thresh" job command
// options.
//
// e.g. rapid_inten        = false;
//      rapid_inten_thresh = >=30.0;
//
rapid_inten        = false;
rapid_inten_thresh = >=30.0;

//
// Specify whether only those track points occurring near landfall should be
// retained, and define the landfall retention window as a number of seconds
// offset from the landfall time.  Landfall is defined as the last BDECK track
// point before the distance to land switches from positive to 0 or negative.
// May modify using the "-landfall", "-landfall_beg", and "-landfall_end" job
// command options.
//
// e.g. landfall     = false;
//      landfall_beg = -86400; (24 hours prior to landfall)
//      landfall_end = 0;
//
landfall     = false;
landfall_beg = -86400;
landfall_end = 0;

//
// Specify whether only those cases common to all models in the dataset should
// be retained.  May modify using the "-event_equal" job command option.
//
// e.g. event_equal = false;
//
event_equal = false;

//
// Apply polyline masking logic to the location of the ADECK track at the
// initialization time.  If it falls outside the mask, discard the entire track.
// May modify using the "-out_init_mask" job command option.
//
// e.g. out_init_mask = "";
//
out_init_mask = "";

//
// Apply polyline masking logic to the location of the ADECK track at the
// valid time.  If it falls outside the mask, discard only the current track
// point.  May modify using the "-out_valid_mask" job command option.
//
// e.g. out_valid_mask = "";
//
out_valid_mask = "";


////////////////////////////////////////////////////////////////////////////////
//
// WaveletStatConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// The "grid_decomp_flag" entry specifies how the grid should be decomposed in
// Wavelet-Stat into dyadic (2^n x 2^n) tiles:
//    - "AUTO" to tile the input data using tiles of dimension n by n where n
//      is the largest integer power of 2 less than the smallest dimension of
//      the input data.  Center as many tiles as possible with no overlap.
//    - "TILE" to use the tile definition specified below.
//    - "PAD" to pad the input data out to the nearest integer power of 2.
//
grid_decomp_flag = AUTO;

//
// The "tile" entry is a dictionary that specifies how tiles should be defined
// in Wavelet-Stat when the "grid_decomp_flag" is set to "TILE":
//
//    - The "width" entry specifies the dimension for all tiles and must be
//      an integer power of 2.
//
//    - The "location" entry is an array of dictionaries where each element
//      consists of an "x_ll" and "y_ll" entry specifying the lower-left (x,y)
//      coordinates of the tile.
//
tile = {
   width = 0;
   location = [
      {
         x_ll = 0;
         y_ll = 0;
      }
   ];
};

//
// The "wavelet" entry is a dictionary in Wavelet-Stat that specifies how the
// wavelet decomposition should be performed:
//
//    - The "type" entry specifies which wavelet should be used.
//
//    - The "member" entry specifies the wavelet shape.
//      http://www.gnu.org/software/gsl/manual/html_node/DWT-Initialization.html
//
//    - Valid combinations of the two are listed below:
//       - "HAAR" for Haar wavelet (member = 2)
//       - "HAAR_CNTR" for Centered-Haar wavelet (member = 2)
//       - "DAUB" for Daubechies wavelet (member = 4, 6, 8, 10, 12, 14, 16,
//         18, 20)
//       - "DAUB_CNTR" for Centered-Daubechies wavelet (member = 4, 6, 8, 10,
//          12, 14, 16, 18, 20)
//       - "BSPLINE" for Bspline wavelet (member = 103, 105, 202, 204, 206,
//         208, 301, 303, 305, 307, 309)
//       - "BSPLINE_CNTR" for Centered-Bspline wavelet (member = 103, 105, 202,
//          204, 206, 208, 301, 303, 305, 307, 309)
//
wavelet = {
   type   = HAAR;
   member = 2;
};

//
// The "obs_raw_plot", "wvlt_plot", and "object_plot" entries are dictionaries
// similar to the "fcst_raw_plot" described in the "Settings common to multiple
// tools" section.
//

////////////////////////////////////////////////////////////////////////////////
//
// WWMCARegridConfig_default
//
////////////////////////////////////////////////////////////////////////////////

//
// Specify the grid to which the data should be interpolated in one of the
// following ways:
//
//    - Name ("GNNN" where NNN indicates the three digit NCEP grid number)
//
//    - lambert Nx Ny lat_ll lon_ll lon_orient D_km R_km standard_parallel_1
//      [standard_parallel_2]
//
//    - stereo Nx Ny lat_ll lon_ll lon_orient D_km R_km lat_scale N|S
//
//    - latlon Nx Ny lat_ll lon_ll delta_lat delta_lon
//
//    - mercator Nx Ny lat_ll lon_ll lat_ur lon_ur
//
to_grid = "lambert 614 428 12.190 -133.459 -95.0 12.19058 6367.47 25.0";

//
// Supply the NetCDF output information
//
// e.g. variable_name = "Cloud_Pct";
//      units         = "percent";
//      long_name     = "cloud cover percent";
//      level         = "SFC";
//
variable_name = "";
units         = "";
long_name     = "";
level         = "";

//
// Maximum pixel age in minutes
//
max_minutes   = 120;
